import {
  require_vdom
} from "./chunk-RA3NQNKU.js";
import "./chunk-NTB57Y6X.js";
import "./chunk-463SBOXY.js";
import "./chunk-B5VZBZDF.js";
import {
  require_index_browser as require_index_browser2
} from "./chunk-T27UHIJZ.js";
import {
  require_update_manager
} from "./chunk-BFAZ6O7V.js";
import {
  require_index_browser
} from "./chunk-DDL5ICIO.js";
import "./chunk-PWCIM3WU.js";
import "./chunk-NISPTXZL.js";
import "./chunk-G6EQPBAW.js";
import "./chunk-WTBMIWQS.js";
import "./chunk-EX4AML7V.js";
import "./chunk-GIKHVMKU.js";
import "./chunk-2APR2CPO.js";
import "./chunk-3BN66U4C.js";
import "./chunk-AUY6IS4O.js";
import "./chunk-CNQJXT2F.js";
import "./chunk-XOFOD672.js";
import {
  __commonJS
} from "./chunk-VUNV25KB.js";

// node_modules/marko/src/runtime/vdom/hot-reload.js
var require_hot_reload = __commonJS({
  "node_modules/marko/src/runtime/vdom/hot-reload.js"(exports) {
    var registry = require_index_browser2();
    var setImmediate = require_index_browser().___setImmediate;
    var updateManager = require_update_manager();
    var runtime = require_vdom();
    var createTemplate = runtime.t;
    var createComponent = registry.___createComponent;
    var registered = {};
    var instancesByType = {};
    var queue;
    exports.t = runtime.t = function(typeName) {
      if (registered[typeName]) {
        return registered[typeName];
      }
      var renderFn;
      var template = registered[typeName] = createTemplate(typeName);
      var instances = instancesByType[typeName] = /* @__PURE__ */ new Set();
      Object.defineProperty(template, "_", {
        get: function() {
          return renderFn && proxyRenderer;
        },
        set: function(v) {
          renderFn = v;
          if (instances.size) {
            if (!queue) {
              queue = [];
              setImmediate(batchUpdate);
            }
            queue.push(function() {
              var newProto = registry.___getComponentClass(typeName).prototype;
              instances.forEach(function(instance) {
                if (hasLifecycleChanged(instance.__proto__, newProto)) {
                  var renderer = instance.___renderer;
                  instance.___renderer = (input, out) => {
                    instance.___emitCreate(input, out);
                    if (instance.onInput) {
                      input = instance.onInput(input, out) || input;
                    }
                    instance.___renderer = renderer;
                    instance.___renderer(input, out);
                  };
                  instance.___hmrDestroyed = true;
                  instance.___emitDestroy();
                  instance.___mounted = false;
                  if (instance.___subscriptions) {
                    instance.___subscriptions.removeAllListeners();
                    instance.___subscriptions = null;
                  }
                }
                instance.__proto__ = newProto;
                instance.___rerender(instance.___input, false).afterInsert(instance.___host);
              });
            });
          }
        }
      });
      return template;
      function proxyRenderer() {
        return renderFn.apply(this, arguments);
      }
    };
    registry.___createComponent = function(typeName, id) {
      var instances = instancesByType[typeName];
      var instance = createComponent(typeName, id);
      if (instances) {
        instances.add(instance);
        instance.once("destroy", function() {
          if (!instance.___hmrDestroyed) {
            instances.delete(instance);
          }
        });
      }
      return instance;
    };
    function hasLifecycleChanged(oldProto, newProto) {
      return hasMethodChanged("onCreate") || hasMethodChanged("onInput") || hasMethodChanged("onRender") || hasMethodChanged("onMount");
      function hasMethodChanged(method) {
        return (oldProto[method] && oldProto[method].toString()) !== (newProto[method] && newProto[method].toString());
      }
    }
    function batchUpdate() {
      updateManager.___batchUpdate(function() {
        var pending = queue;
        queue = void 0;
        for (var i = 0; i < pending.length; i++) {
          pending[i]();
        }
      });
    }
  }
});
export default require_hot_reload();
//# sourceMappingURL=marko_src_runtime_vdom_hot-reload__js.js.map
