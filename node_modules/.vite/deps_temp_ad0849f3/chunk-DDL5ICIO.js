import {
  require_fragment,
  require_helpers,
  require_vdom
} from "./chunk-PWCIM3WU.js";
import {
  require_KeySequence
} from "./chunk-2APR2CPO.js";
import {
  require_extend
} from "./chunk-3BN66U4C.js";
import {
  require_complain
} from "./chunk-AUY6IS4O.js";
import {
  require_event_delegation
} from "./chunk-CNQJXT2F.js";
import {
  require_dom_data,
  require_index_browser
} from "./chunk-XOFOD672.js";
import {
  __commonJS
} from "./chunk-VUNV25KB.js";

// node_modules/marko/src/node_modules/@internal/set-immediate/queueMicrotask.js
var require_queueMicrotask = __commonJS({
  "node_modules/marko/src/node_modules/@internal/set-immediate/queueMicrotask.js"(exports, module) {
    var promise;
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask : (promise = Promise.resolve(), function(cb) {
      promise.then(cb);
    });
  }
});

// node_modules/marko/src/node_modules/@internal/set-immediate/index-browser.js
var require_index_browser2 = __commonJS({
  "node_modules/marko/src/node_modules/@internal/set-immediate/index-browser.js"(exports) {
    var queue = [];
    var msg = "" + Math.random();
    window.addEventListener("message", function(ev) {
      if (ev.data === msg) {
        var callbacks = queue;
        queue = [];
        for (var i = 0; i < callbacks.length; i++) {
          callbacks[i]();
        }
      }
    });
    exports.___setImmediate = function(callback) {
      if (queue.push(callback) === 1) {
        window.postMessage(msg, "*");
      }
    };
    exports.___queueMicrotask = require_queueMicrotask();
  }
});

// node_modules/marko/src/runtime/createOut.js
var require_createOut = __commonJS({
  "node_modules/marko/src/runtime/createOut.js"(exports, module) {
    var actualCreateOut;
    function setCreateOut(createOutFunc) {
      actualCreateOut = createOutFunc;
    }
    function createOut(globalData) {
      return actualCreateOut(globalData);
    }
    createOut.___setCreateOut = setCreateOut;
    module.exports = createOut;
  }
});

// node_modules/events-light/src/index.js
var require_src = __commonJS({
  "node_modules/events-light/src/index.js"(exports, module) {
    var slice = Array.prototype.slice;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    function checkListener(listener) {
      if (!isFunction(listener)) {
        throw TypeError("Invalid listener");
      }
    }
    function invokeListener(ee, listener, args) {
      switch (args.length) {
        case 1:
          listener.call(ee);
          break;
        case 2:
          listener.call(ee, args[1]);
          break;
        case 3:
          listener.call(ee, args[1], args[2]);
          break;
        default:
          listener.apply(ee, slice.call(args, 1));
      }
    }
    function addListener(eventEmitter, type, listener, prepend) {
      checkListener(listener);
      var events = eventEmitter.$e || (eventEmitter.$e = {});
      var listeners = events[type];
      if (listeners) {
        if (isFunction(listeners)) {
          events[type] = prepend ? [listener, listeners] : [listeners, listener];
        } else {
          if (prepend) {
            listeners.unshift(listener);
          } else {
            listeners.push(listener);
          }
        }
      } else {
        events[type] = listener;
      }
      return eventEmitter;
    }
    function EventEmitter() {
      this.$e = this.$e || {};
    }
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype = {
      $e: null,
      emit: function(type) {
        var args = arguments;
        var events = this.$e;
        if (!events) {
          return;
        }
        var listeners = events && events[type];
        if (!listeners) {
          if (type === "error") {
            var error = args[1];
            if (!(error instanceof Error)) {
              var context = error;
              error = new Error("Error: " + context);
              error.context = context;
            }
            throw error;
          }
          return false;
        }
        if (isFunction(listeners)) {
          invokeListener(this, listeners, args);
        } else {
          listeners = slice.call(listeners);
          for (var i = 0, len = listeners.length; i < len; i++) {
            var listener = listeners[i];
            invokeListener(this, listener, args);
          }
        }
        return true;
      },
      on: function(type, listener) {
        return addListener(this, type, listener, false);
      },
      prependListener: function(type, listener) {
        return addListener(this, type, listener, true);
      },
      once: function(type, listener) {
        checkListener(listener);
        function g() {
          this.removeListener(type, g);
          if (listener) {
            listener.apply(this, arguments);
            listener = null;
          }
        }
        this.on(type, g);
        return this;
      },
      // emits a 'removeListener' event iff the listener was removed
      removeListener: function(type, listener) {
        checkListener(listener);
        var events = this.$e;
        var listeners;
        if (events && (listeners = events[type])) {
          if (isFunction(listeners)) {
            if (listeners === listener) {
              delete events[type];
            }
          } else {
            for (var i = listeners.length - 1; i >= 0; i--) {
              if (listeners[i] === listener) {
                listeners.splice(i, 1);
              }
            }
          }
        }
        return this;
      },
      removeAllListeners: function(type) {
        var events = this.$e;
        if (events) {
          delete events[type];
        }
      },
      listenerCount: function(type) {
        var events = this.$e;
        var listeners = events && events[type];
        return listeners ? isFunction(listeners) ? 1 : listeners.length : 0;
      }
    };
    module.exports = EventEmitter;
  }
});

// node_modules/marko/src/runtime/dom-insert.js
var require_dom_insert = __commonJS({
  "node_modules/marko/src/runtime/dom-insert.js"(exports, module) {
    var extend = require_extend();
    var componentsUtil = require_index_browser();
    var destroyComponentForNode = componentsUtil.___destroyComponentForNode;
    var destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;
    var helpers = require_helpers();
    var insertBefore = helpers.___insertBefore;
    var insertAfter = helpers.___insertAfter;
    var removeChild = helpers.___removeChild;
    function resolveEl(el) {
      if (typeof el == "string") {
        var elId = el;
        el = document.getElementById(elId);
        if (!el) {
          throw Error("Not found: " + elId);
        }
      }
      return el;
    }
    function beforeRemove(referenceEl) {
      destroyNodeRecursive(referenceEl);
      destroyComponentForNode(referenceEl);
    }
    module.exports = function(target, getEl, afterInsert) {
      extend(target, {
        appendTo: function(referenceEl) {
          referenceEl = resolveEl(referenceEl);
          var el = getEl(this, referenceEl);
          insertBefore(el, null, referenceEl);
          return afterInsert(this, referenceEl);
        },
        prependTo: function(referenceEl) {
          referenceEl = resolveEl(referenceEl);
          var el = getEl(this, referenceEl);
          insertBefore(el, referenceEl.firstChild || null, referenceEl);
          return afterInsert(this, referenceEl);
        },
        replace: function(referenceEl) {
          referenceEl = resolveEl(referenceEl);
          var el = getEl(this, referenceEl);
          beforeRemove(referenceEl);
          insertBefore(el, referenceEl, referenceEl.parentNode);
          removeChild(referenceEl);
          return afterInsert(this, referenceEl);
        },
        replaceChildrenOf: function(referenceEl) {
          referenceEl = resolveEl(referenceEl);
          var el = getEl(this, referenceEl);
          var curChild = referenceEl.firstChild;
          while (curChild) {
            var nextSibling = curChild.nextSibling;
            beforeRemove(curChild);
            curChild = nextSibling;
          }
          referenceEl.innerHTML = "";
          insertBefore(el, null, referenceEl);
          return afterInsert(this, referenceEl);
        },
        insertBefore: function(referenceEl) {
          referenceEl = resolveEl(referenceEl);
          var el = getEl(this, referenceEl);
          insertBefore(el, referenceEl, referenceEl.parentNode);
          return afterInsert(this, referenceEl);
        },
        insertAfter: function(referenceEl) {
          referenceEl = resolveEl(referenceEl);
          var el = getEl(this, referenceEl);
          insertAfter(el, referenceEl, referenceEl.parentNode);
          return afterInsert(this, referenceEl);
        }
      });
    };
  }
});

// node_modules/marko/src/runtime/RenderResult.js
var require_RenderResult = __commonJS({
  "node_modules/marko/src/runtime/RenderResult.js"(exports, module) {
    var domInsert = require_dom_insert();
    var complain = require_complain();
    function getRootNode(el) {
      var cur = el;
      while (cur.parentNode) cur = cur.parentNode;
      return cur;
    }
    function getComponentDefs(result) {
      var componentDefs = result.___components;
      if (!componentDefs) {
        throw Error("No component");
      }
      return componentDefs;
    }
    function RenderResult(out) {
      this.out = this.___out = out;
      this.___components = void 0;
    }
    module.exports = RenderResult;
    var proto = RenderResult.prototype = {
      getComponent: function() {
        return this.getComponents()[0];
      },
      getComponents: function(selector) {
        if (this.___components === void 0) {
          throw Error("Not added to DOM");
        }
        var componentDefs = getComponentDefs(this);
        var components = [];
        componentDefs.forEach(function(componentDef) {
          var component = componentDef.___component;
          if (!selector || selector(component)) {
            components.push(component);
          }
        });
        return components;
      },
      afterInsert: function(host) {
        var out = this.___out;
        var componentsContext = out.___components;
        if (componentsContext) {
          this.___components = componentsContext.___initComponents(host);
        } else {
          this.___components = null;
        }
        return this;
      },
      getNode: function(host) {
        return this.___out.___getNode(host);
      },
      getOutput: function() {
        return this.___out.___getOutput();
      },
      toString: function() {
        return this.___out.toString();
      },
      document: typeof document === "object" && document
    };
    Object.defineProperty(proto, "html", {
      get: function() {
        if ("MARKO_DEBUG") {
          complain(
            'The "html" property is deprecated. Please use "toString" instead.'
          );
        }
        return this.toString();
      }
    });
    Object.defineProperty(proto, "context", {
      get: function() {
        if ("MARKO_DEBUG") {
          complain(
            'The "context" property is deprecated. Please use "out" instead.'
          );
        }
        return this.___out;
      }
    });
    domInsert(
      proto,
      function getEl(renderResult, referenceEl) {
        return renderResult.getNode(getRootNode(referenceEl));
      },
      function afterInsert(renderResult, referenceEl) {
        return renderResult.afterInsert(getRootNode(referenceEl));
      }
    );
  }
});

// node_modules/marko/src/runtime/vdom/morphdom/index.js
var require_morphdom = __commonJS({
  "node_modules/marko/src/runtime/vdom/morphdom/index.js"(exports, module) {
    "use strict";
    var componentsUtil = require_index_browser();
    var existingComponentLookup = componentsUtil.___componentLookup;
    var destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;
    var addComponentRootToKeyedElements = componentsUtil.___addComponentRootToKeyedElements;
    var normalizeComponentKey = componentsUtil.___normalizeComponentKey;
    var domData = require_dom_data();
    var eventDelegation = require_event_delegation();
    var KeySequence = require_KeySequence();
    var VElement = require_vdom().___VElement;
    var fragment = require_fragment();
    var helpers = require_helpers();
    var virtualizeElement = VElement.___virtualize;
    var morphAttrs = VElement.___morphAttrs;
    var keysByDOMNode = domData.___keyByDOMNode;
    var componentByDOMNode = domData.___componentByDOMNode;
    var vElementByDOMNode = domData.___vElementByDOMNode;
    var detachedByDOMNode = domData.___detachedByDOMNode;
    var insertBefore = helpers.___insertBefore;
    var insertAfter = helpers.___insertAfter;
    var nextSibling = helpers.___nextSibling;
    var firstChild = helpers.___firstChild;
    var removeChild = helpers.___removeChild;
    var createFragmentNode = fragment.___createFragmentNode;
    var beginFragmentNode = fragment.___beginFragmentNode;
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    var COMPONENT_NODE = 2;
    var FRAGMENT_NODE = 12;
    var DOCTYPE_NODE = 10;
    function isAutoKey(key) {
      return key[0] !== "@";
    }
    function compareNodeNames(fromEl, toEl) {
      return fromEl.___nodeName === toEl.___nodeName;
    }
    function caseInsensitiveCompare(a, b) {
      return a.toLowerCase() === b.toLowerCase();
    }
    function onNodeAdded(node, componentsContext) {
      if (node.nodeType === ELEMENT_NODE) {
        eventDelegation.___handleNodeAttach(node, componentsContext);
      }
    }
    function morphdom(fromNode, toNode, host, componentsContext) {
      var globalComponentsContext;
      var isHydrate = false;
      var keySequences = /* @__PURE__ */ Object.create(null);
      if (componentsContext) {
        globalComponentsContext = componentsContext.___globalContext;
        isHydrate = globalComponentsContext.___isHydrate;
      }
      function insertVirtualNodeBefore(vNode, key, referenceEl, parentEl, ownerComponent, parentComponent) {
        var realNode = vNode.___actualize(host, parentEl.namespaceURI);
        insertBefore(realNode, referenceEl, parentEl);
        if (vNode.___nodeType === ELEMENT_NODE || vNode.___nodeType === FRAGMENT_NODE) {
          if (key) {
            keysByDOMNode.set(realNode, key);
            (isAutoKey(key) ? parentComponent : ownerComponent).___keyedElements[key] = realNode;
          }
          if (vNode.___nodeName !== "textarea") {
            morphChildren(realNode, vNode, parentComponent);
          }
          onNodeAdded(realNode, componentsContext);
        }
      }
      function insertVirtualComponentBefore(vComponent, referenceNode, referenceNodeParentEl, component, key, ownerComponent, parentComponent) {
        var rootNode = component.___rootNode = insertBefore(
          createFragmentNode(),
          referenceNode,
          referenceNodeParentEl
        );
        componentByDOMNode.set(rootNode, component);
        if (key && ownerComponent) {
          key = normalizeComponentKey(key, parentComponent.id);
          addComponentRootToKeyedElements(
            ownerComponent.___keyedElements,
            key,
            rootNode,
            component.id
          );
          keysByDOMNode.set(rootNode, key);
        }
        morphComponent(component, vComponent);
      }
      function morphComponent(component, vComponent) {
        morphChildren(component.___rootNode, vComponent, component);
      }
      var detachedNodes = [];
      function detachNode(node, parentNode, ownerComponent) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === FRAGMENT_NODE) {
          detachedNodes.push(node);
          detachedByDOMNode.set(node, ownerComponent || true);
        } else {
          destroyNodeRecursive(node);
          removeChild(node);
        }
      }
      function destroyComponent(component) {
        component.destroy();
      }
      function morphChildren(fromNode2, toNode2, parentComponent) {
        var curFromNodeChild = firstChild(fromNode2);
        var curToNodeChild = toNode2.___firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var curToNodeType;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        var matchingFromComponent;
        var curVFromNodeChild;
        var fromComponent;
        outer: while (curToNodeChild) {
          toNextSibling = curToNodeChild.___nextSibling;
          curToNodeType = curToNodeChild.___nodeType;
          curToNodeKey = curToNodeChild.___key;
          if (curFromNodeChild && curFromNodeChild.nodeType === DOCTYPE_NODE) {
            curFromNodeChild = nextSibling(curFromNodeChild);
          }
          var ownerComponent = curToNodeChild.___ownerComponent || parentComponent;
          var referenceComponent;
          if (curToNodeType === COMPONENT_NODE) {
            var component = curToNodeChild.___component;
            if ((matchingFromComponent = existingComponentLookup[component.id]) === void 0) {
              if (isHydrate) {
                var rootNode = beginFragmentNode(curFromNodeChild, fromNode2);
                component.___rootNode = rootNode;
                componentByDOMNode.set(rootNode, component);
                if (ownerComponent && curToNodeKey) {
                  curToNodeKey = normalizeComponentKey(
                    curToNodeKey,
                    parentComponent.id
                  );
                  addComponentRootToKeyedElements(
                    ownerComponent.___keyedElements,
                    curToNodeKey,
                    rootNode,
                    component.id
                  );
                  keysByDOMNode.set(rootNode, curToNodeKey);
                }
                morphComponent(component, curToNodeChild);
                curFromNodeChild = nextSibling(rootNode);
              } else {
                insertVirtualComponentBefore(
                  curToNodeChild,
                  curFromNodeChild,
                  fromNode2,
                  component,
                  curToNodeKey,
                  ownerComponent,
                  parentComponent
                );
              }
            } else {
              if (matchingFromComponent.___rootNode !== curFromNodeChild) {
                if (curFromNodeChild && (fromComponent = componentByDOMNode.get(curFromNodeChild)) && globalComponentsContext.___renderedComponentsById[fromComponent.id] === void 0) {
                  curFromNodeChild = nextSibling(fromComponent.___rootNode);
                  destroyComponent(fromComponent);
                  continue;
                }
                insertBefore(
                  matchingFromComponent.___rootNode,
                  curFromNodeChild,
                  fromNode2
                );
              } else {
                curFromNodeChild = curFromNodeChild && nextSibling(curFromNodeChild);
              }
              if (!curToNodeChild.___preserve) {
                morphComponent(component, curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            continue;
          } else if (curToNodeKey) {
            curVFromNodeChild = void 0;
            curFromNodeKey = void 0;
            var curToNodeKeyOriginal = curToNodeKey;
            if (isAutoKey(curToNodeKey)) {
              if (ownerComponent !== parentComponent) {
                curToNodeKey += ":" + ownerComponent.id;
              }
              referenceComponent = parentComponent;
            } else {
              referenceComponent = ownerComponent;
            }
            curToNodeKey = (keySequences[referenceComponent.id] || (keySequences[referenceComponent.id] = new KeySequence())).___nextKey(curToNodeKey);
            if (curFromNodeChild) {
              curFromNodeKey = keysByDOMNode.get(curFromNodeChild);
              curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);
              fromNextSibling = nextSibling(curFromNodeChild);
            }
            if (curFromNodeKey === curToNodeKey) {
              if (!curToNodeChild.___preserve) {
                if (curVFromNodeChild && curToNodeType === curVFromNodeChild.___nodeType && (curToNodeType !== ELEMENT_NODE || compareNodeNames(curToNodeChild, curVFromNodeChild))) {
                  if (curToNodeType === ELEMENT_NODE) {
                    morphEl(
                      curFromNodeChild,
                      curVFromNodeChild,
                      curToNodeChild,
                      parentComponent
                    );
                  } else {
                    morphChildren(
                      curFromNodeChild,
                      curToNodeChild,
                      parentComponent
                    );
                  }
                } else {
                  detachNode(curFromNodeChild, fromNode2, ownerComponent);
                  insertVirtualNodeBefore(
                    curToNodeChild,
                    curToNodeKey,
                    curFromNodeChild,
                    fromNode2,
                    ownerComponent,
                    parentComponent
                  );
                }
              }
            } else {
              matchingFromEl = referenceComponent.___keyedElements[curToNodeKey];
              if (matchingFromEl === void 0 || matchingFromEl === curFromNodeChild) {
                if (isHydrate && curFromNodeChild) {
                  if (curFromNodeChild.nodeType === ELEMENT_NODE && (curToNodeChild.___preserve || caseInsensitiveCompare(
                    curFromNodeChild.nodeName,
                    curToNodeChild.___nodeName || ""
                  ))) {
                    curVFromNodeChild = virtualizeElement(curFromNodeChild);
                    curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;
                    keysByDOMNode.set(curFromNodeChild, curToNodeKey);
                    referenceComponent.___keyedElements[curToNodeKey] = curFromNodeChild;
                    if (curToNodeChild.___preserve) {
                      vElementByDOMNode.set(curFromNodeChild, curVFromNodeChild);
                    } else {
                      morphEl(
                        curFromNodeChild,
                        curVFromNodeChild,
                        curToNodeChild,
                        parentComponent
                      );
                    }
                    curToNodeChild = toNextSibling;
                    curFromNodeChild = fromNextSibling;
                    continue;
                  } else if (curToNodeChild.___nodeType === FRAGMENT_NODE && curFromNodeChild.nodeType === COMMENT_NODE) {
                    var content = curFromNodeChild.nodeValue;
                    if (content == "F#" + curToNodeKeyOriginal) {
                      var endNode = curFromNodeChild.nextSibling;
                      var depth = 0;
                      var nodeValue;
                      while (true) {
                        if (endNode.nodeType === COMMENT_NODE) {
                          nodeValue = endNode.nodeValue;
                          if (nodeValue === "F/") {
                            if (depth === 0) {
                              break;
                            } else {
                              depth--;
                            }
                          } else if (nodeValue.indexOf("F#") === 0) {
                            depth++;
                          }
                        }
                        endNode = endNode.nextSibling;
                      }
                      var fragment2 = createFragmentNode(
                        curFromNodeChild,
                        endNode.nextSibling,
                        fromNode2
                      );
                      keysByDOMNode.set(fragment2, curToNodeKey);
                      vElementByDOMNode.set(fragment2, curToNodeChild);
                      referenceComponent.___keyedElements[curToNodeKey] = fragment2;
                      removeChild(curFromNodeChild);
                      removeChild(endNode);
                      if (!curToNodeChild.___preserve) {
                        morphChildren(fragment2, curToNodeChild, parentComponent);
                      }
                      curToNodeChild = toNextSibling;
                      curFromNodeChild = fragment2.nextSibling;
                      continue;
                    }
                  }
                }
                insertVirtualNodeBefore(
                  curToNodeChild,
                  curToNodeKey,
                  curFromNodeChild,
                  fromNode2,
                  ownerComponent,
                  parentComponent
                );
                fromNextSibling = curFromNodeChild;
              } else {
                if (detachedByDOMNode.get(matchingFromEl) !== void 0) {
                  detachedByDOMNode.set(matchingFromEl, void 0);
                }
                if (!curToNodeChild.___preserve) {
                  curVFromNodeChild = vElementByDOMNode.get(matchingFromEl);
                  if (curVFromNodeChild && curToNodeType === curVFromNodeChild.___nodeType && (curToNodeType !== ELEMENT_NODE || compareNodeNames(curVFromNodeChild, curToNodeChild))) {
                    if (fromNextSibling === matchingFromEl) {
                      if (toNextSibling && toNextSibling.___key === curFromNodeKey) {
                        fromNextSibling = curFromNodeChild;
                        insertBefore(matchingFromEl, curFromNodeChild, fromNode2);
                      } else {
                        fromNextSibling = nextSibling(fromNextSibling);
                        if (curFromNodeChild) {
                          detachNode(curFromNodeChild, fromNode2, ownerComponent);
                        }
                      }
                    } else {
                      insertAfter(matchingFromEl, curFromNodeChild, fromNode2);
                      if (curFromNodeChild) {
                        detachNode(curFromNodeChild, fromNode2, ownerComponent);
                      }
                    }
                    if (curToNodeType === ELEMENT_NODE) {
                      morphEl(
                        matchingFromEl,
                        curVFromNodeChild,
                        curToNodeChild,
                        parentComponent
                      );
                    } else {
                      morphChildren(
                        matchingFromEl,
                        curToNodeChild,
                        parentComponent
                      );
                    }
                  } else {
                    insertVirtualNodeBefore(
                      curToNodeChild,
                      curToNodeKey,
                      curFromNodeChild,
                      fromNode2,
                      ownerComponent,
                      parentComponent
                    );
                    detachNode(matchingFromEl, fromNode2, ownerComponent);
                  }
                } else {
                  insertBefore(matchingFromEl, curFromNodeChild, fromNode2);
                  fromNextSibling = curFromNodeChild;
                }
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
            continue;
          }
          while (curFromNodeChild) {
            fromNextSibling = nextSibling(curFromNodeChild);
            if (fromComponent = componentByDOMNode.get(curFromNodeChild)) {
              curFromNodeChild = fromNextSibling;
              if (!globalComponentsContext.___renderedComponentsById[fromComponent.id]) {
                destroyComponent(fromComponent);
              }
              continue;
            }
            var curFromNodeType = curFromNodeChild.nodeType;
            var isCompatible = void 0;
            if (curFromNodeType === curToNodeType) {
              if (curFromNodeType === ELEMENT_NODE) {
                curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);
                if (curVFromNodeChild === void 0) {
                  if (isHydrate) {
                    curVFromNodeChild = virtualizeElement(curFromNodeChild);
                    if (caseInsensitiveCompare(
                      curVFromNodeChild.___nodeName,
                      curToNodeChild.___nodeName
                    )) {
                      curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;
                    }
                  } else {
                    curFromNodeChild = fromNextSibling;
                    continue;
                  }
                } else if (curFromNodeKey = curVFromNodeChild.___key) {
                  isCompatible = false;
                }
                isCompatible = isCompatible !== false && compareNodeNames(curVFromNodeChild, curToNodeChild) === true;
                if (isCompatible === true) {
                  morphEl(
                    curFromNodeChild,
                    curVFromNodeChild,
                    curToNodeChild,
                    parentComponent
                  );
                }
              } else if (curFromNodeType === TEXT_NODE || curFromNodeType === COMMENT_NODE) {
                isCompatible = true;
                var curToNodeValue = curToNodeChild.___nodeValue;
                var curFromNodeValue = curFromNodeChild.nodeValue;
                if (curFromNodeValue !== curToNodeValue) {
                  if (isHydrate && toNextSibling && curFromNodeType === TEXT_NODE && toNextSibling.___nodeType === TEXT_NODE && curFromNodeValue.startsWith(curToNodeValue) && curFromNodeValue.slice(curToNodeValue.length).startsWith(toNextSibling.___nodeValue)) {
                    fromNextSibling = curFromNodeChild.splitText(
                      curToNodeValue.length
                    );
                  } else {
                    curFromNodeChild.nodeValue = curToNodeValue;
                  }
                }
              }
            }
            if (isCompatible === true) {
              curToNodeChild = toNextSibling;
              curFromNodeChild = fromNextSibling;
              continue outer;
            }
            detachNode(curFromNodeChild, fromNode2, ownerComponent);
            curFromNodeChild = fromNextSibling;
          }
          insertVirtualNodeBefore(
            curToNodeChild,
            curToNodeKey,
            curFromNodeChild,
            fromNode2,
            ownerComponent,
            parentComponent
          );
          curToNodeChild = toNextSibling;
          curFromNodeChild = fromNextSibling;
        }
        if (fromNode2.___finishFragment) {
          fromNode2.___finishFragment(curFromNodeChild);
        } else {
          var fragmentBoundary = fromNode2.nodeType === FRAGMENT_NODE ? fromNode2.endNode : null;
          while (curFromNodeChild && curFromNodeChild !== fragmentBoundary) {
            fromNextSibling = nextSibling(curFromNodeChild);
            if (fromComponent = componentByDOMNode.get(curFromNodeChild)) {
              curFromNodeChild = fromNextSibling;
              if (!globalComponentsContext.___renderedComponentsById[fromComponent.id]) {
                destroyComponent(fromComponent);
              }
              continue;
            }
            curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);
            curFromNodeKey = keysByDOMNode.get(fromNode2);
            if (!curFromNodeKey || isAutoKey(curFromNodeKey)) {
              referenceComponent = parentComponent;
            } else {
              referenceComponent = curVFromNodeChild && curVFromNodeChild.___ownerComponent;
            }
            detachNode(curFromNodeChild, fromNode2, referenceComponent);
            curFromNodeChild = fromNextSibling;
          }
        }
      }
      function morphEl(fromEl, vFromEl, toEl, parentComponent) {
        var nodeName = toEl.___nodeName;
        var constId = toEl.___constId;
        vElementByDOMNode.set(fromEl, toEl);
        if (constId !== void 0 && vFromEl.___constId === constId) {
          return;
        }
        morphAttrs(fromEl, vFromEl, toEl);
        if (toEl.___preserveBody) {
          return;
        }
        if (nodeName === "textarea") {
          if (toEl.___valueInternal !== vFromEl.___valueInternal) {
            fromEl.value = toEl.___valueInternal;
          }
        } else {
          morphChildren(fromEl, toEl, parentComponent);
        }
      }
      morphChildren(fromNode, toNode, toNode.___component);
      detachedNodes.forEach(function(node) {
        var detachedFromComponent = detachedByDOMNode.get(node);
        if (detachedFromComponent !== void 0) {
          detachedByDOMNode.set(node, void 0);
          var componentToDestroy = componentByDOMNode.get(node);
          if (componentToDestroy) {
            componentToDestroy.destroy();
          } else if (node.parentNode) {
            destroyNodeRecursive(
              node,
              detachedFromComponent !== true && detachedFromComponent
            );
            if (eventDelegation.___handleNodeDetach(node) != false) {
              removeChild(node);
            }
          }
        }
      });
    }
    module.exports = morphdom;
  }
});

export {
  require_index_browser2 as require_index_browser,
  require_src,
  require_createOut,
  require_dom_insert,
  require_RenderResult,
  require_morphdom
};
//# sourceMappingURL=chunk-DDL5ICIO.js.map
