import {
  require_parse_html
} from "./chunk-NISPTXZL.js";
import {
  require_extend
} from "./chunk-3BN66U4C.js";
import {
  require_complain
} from "./chunk-AUY6IS4O.js";
import {
  require_dom_data,
  require_index_browser
} from "./chunk-XOFOD672.js";
import {
  __commonJS
} from "./chunk-VUNV25KB.js";

// node_modules/raptor-util/copyProps.js
var require_copyProps = __commonJS({
  "node_modules/raptor-util/copyProps.js"(exports, module) {
    module.exports = function copyProps(from, to) {
      Object.getOwnPropertyNames(from).forEach(function(name) {
        var descriptor = Object.getOwnPropertyDescriptor(from, name);
        Object.defineProperty(to, name, descriptor);
      });
    };
  }
});

// node_modules/raptor-util/inherit.js
var require_inherit = __commonJS({
  "node_modules/raptor-util/inherit.js"(exports, module) {
    var copyProps = require_copyProps();
    function inherit(ctor, superCtor, shouldCopyProps) {
      var oldProto = ctor.prototype;
      var newProto = ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          writable: true,
          configurable: true
        }
      });
      if (oldProto && shouldCopyProps !== false) {
        copyProps(oldProto, newProto);
      }
      ctor.$super = superCtor;
      ctor.prototype = newProto;
      return ctor;
    }
    module.exports = inherit;
    inherit._inherit = inherit;
  }
});

// node_modules/marko/src/runtime/vdom/VNode.js
var require_VNode = __commonJS({
  "node_modules/marko/src/runtime/vdom/VNode.js"(exports, module) {
    function VNode() {
    }
    VNode.prototype = {
      ___VNode: function(finalChildCount, ownerComponent) {
        this.___finalChildCount = finalChildCount;
        this.___childCount = 0;
        this.___firstChildInternal = null;
        this.___lastChild = null;
        this.___parentNode = null;
        this.___nextSiblingInternal = null;
        this.___ownerComponent = ownerComponent;
      },
      get ___firstChild() {
        var firstChild = this.___firstChildInternal;
        if (firstChild && firstChild.___DocumentFragment) {
          var nestedFirstChild = firstChild.___firstChild;
          return nestedFirstChild || firstChild.___nextSibling;
        }
        return firstChild;
      },
      get ___nextSibling() {
        var nextSibling = this.___nextSiblingInternal;
        if (nextSibling) {
          if (nextSibling.___DocumentFragment) {
            var firstChild = nextSibling.___firstChild;
            return firstChild || nextSibling.___nextSibling;
          }
        } else {
          var parentNode = this.___parentNode;
          if (parentNode && parentNode.___DocumentFragment) {
            return parentNode.___nextSibling;
          }
        }
        return nextSibling;
      },
      ___appendChild: function(child) {
        this.___childCount++;
        if (this.___nodeName === "textarea") {
          if (child.___Text) {
            this.___valueInternal += child.___nodeValue;
          } else {
            throw TypeError();
          }
        } else {
          var lastChild = this.___lastChild;
          child.___parentNode = this;
          if (lastChild) {
            lastChild.___nextSiblingInternal = child;
          } else {
            this.___firstChildInternal = child;
          }
          this.___lastChild = child;
        }
        return child;
      },
      ___finishChild: function finishChild() {
        if (this.___childCount === this.___finalChildCount && this.___parentNode) {
          return this.___parentNode.___finishChild();
        } else {
          return this;
        }
      }
      // ,toJSON: function() {
      //     var clone = Object.assign({
      //         nodeType: this.nodeType
      //     }, this);
      //
      //     for (var k in clone) {
      //         if (k.startsWith('_')) {
      //             delete clone[k];
      //         }
      //     }
      //     delete clone._nextSibling;
      //     delete clone._lastChild;
      //     delete clone.parentNode;
      //     return clone;
      // }
    };
    module.exports = VNode;
  }
});

// node_modules/marko/src/runtime/vdom/VComment.js
var require_VComment = __commonJS({
  "node_modules/marko/src/runtime/vdom/VComment.js"(exports, module) {
    var VNode = require_VNode();
    var inherit = require_inherit();
    function VComment(value, ownerComponent) {
      this.___VNode(-1, ownerComponent);
      this.___nodeValue = value;
    }
    VComment.prototype = {
      ___nodeType: 8,
      ___actualize: function(doc) {
        var nodeValue = this.___nodeValue;
        return doc.createComment(nodeValue);
      },
      ___cloneNode: function() {
        return new VComment(this.___nodeValue);
      }
    };
    inherit(VComment, VNode);
    module.exports = VComment;
  }
});

// node_modules/marko/src/runtime/vdom/VComponent.js
var require_VComponent = __commonJS({
  "node_modules/marko/src/runtime/vdom/VComponent.js"(exports, module) {
    var inherit = require_inherit();
    var VNode = require_VNode();
    function VComponent(component, key, ownerComponent, preserve) {
      this.___VNode(null, ownerComponent);
      this.___key = key;
      this.___component = component;
      this.___preserve = preserve;
    }
    VComponent.prototype = {
      ___nodeType: 2
    };
    inherit(VComponent, VNode);
    module.exports = VComponent;
  }
});

// node_modules/marko/src/runtime/vdom/VDocumentFragment.js
var require_VDocumentFragment = __commonJS({
  "node_modules/marko/src/runtime/vdom/VDocumentFragment.js"(exports, module) {
    var extend = require_extend();
    var inherit = require_inherit();
    var VNode = require_VNode();
    function VDocumentFragmentClone(other) {
      extend(this, other);
      this.___parentNode = null;
      this.___nextSiblingInternal = null;
    }
    function VDocumentFragment(out) {
      this.___VNode(
        null
        /* childCount */
      );
      this.___out = out;
    }
    VDocumentFragment.prototype = {
      ___nodeType: 11,
      ___DocumentFragment: true,
      ___cloneNode: function() {
        return new VDocumentFragmentClone(this);
      },
      ___actualize: function(host) {
        return (host.ownerDocument || host).createDocumentFragment();
      }
    };
    inherit(VDocumentFragment, VNode);
    VDocumentFragmentClone.prototype = VDocumentFragment.prototype;
    module.exports = VDocumentFragment;
  }
});

// node_modules/marko/src/runtime/vdom/VElement.js
var require_VElement = __commonJS({
  "node_modules/marko/src/runtime/vdom/VElement.js"(exports, module) {
    var complain = require_complain();
    var inherit = require_inherit();
    var componentsUtil = require_index_browser();
    var domData = require_dom_data();
    var vElementByDOMNode = domData.___vElementByDOMNode;
    var VNode = require_VNode();
    var ATTR_XLINK_HREF = "xlink:href";
    var xmlnsRegExp = /^xmlns(:|$)/;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var NS_XLINK = "http://www.w3.org/1999/xlink";
    var NS_HTML = "http://www.w3.org/1999/xhtml";
    var NS_MATH = "http://www.w3.org/1998/Math/MathML";
    var NS_SVG = "http://www.w3.org/2000/svg";
    var DEFAULT_NS = {
      svg: NS_SVG,
      math: NS_MATH
    };
    var FLAG_SIMPLE_ATTRS = 1;
    var FLAG_CUSTOM_ELEMENT = 2;
    var FLAG_SPREAD_ATTRS = 4;
    var ATTR_HREF = "href";
    var EMPTY_OBJECT = Object.freeze(/* @__PURE__ */ Object.create(null));
    var specialElHandlers = {
      option: {
        selected: function(fromEl, value) {
          fromEl.selected = value !== void 0;
        }
      },
      input: {
        value: function(fromEl, value) {
          fromEl.value = value === void 0 ? "" : value;
        },
        checked: function(fromEl, value) {
          fromEl.checked = value !== void 0;
        }
      }
    };
    function normalizeValue(value) {
      if (value === true) {
        return "";
      }
      if (value == null || value === false) {
        return;
      }
      switch (typeof value) {
        case "string":
          return value;
        case "object":
          switch (value.toString) {
            case Object.prototype.toString:
            case Array.prototype.toString:
              if ("MARKO_DEBUG") {
                complain(
                  "Relying on JSON.stringify for attribute values is deprecated, in future versions of Marko these will be cast to strings instead."
                );
              }
              return JSON.stringify(value);
            case RegExp.prototype.toString:
              return value.source;
          }
          break;
      }
      return value + "";
    }
    function assign(a, b) {
      for (var key in b) {
        if (hasOwnProperty.call(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function VElementClone(other) {
      this.___firstChildInternal = other.___firstChildInternal;
      this.___parentNode = null;
      this.___nextSiblingInternal = null;
      this.___key = other.___key;
      this.___attributes = other.___attributes;
      this.___properties = other.___properties;
      this.___nodeName = other.___nodeName;
      this.___flags = other.___flags;
      this.___valueInternal = other.___valueInternal;
      this.___constId = other.___constId;
    }
    function VElement(tagName, attrs, key, ownerComponent, childCount, flags, props) {
      this.___VNode(childCount, ownerComponent);
      var constId;
      if (props) {
        constId = props.i;
      }
      this.___key = key;
      this.___flags = flags || 0;
      this.___attributes = attrs || EMPTY_OBJECT;
      this.___properties = props || EMPTY_OBJECT;
      this.___nodeName = tagName;
      this.___valueInternal = "";
      this.___constId = constId;
      this.___preserve = false;
      this.___preserveBody = false;
    }
    VElement.prototype = {
      ___nodeType: 1,
      ___cloneNode: function() {
        return new VElementClone(this);
      },
      /**
       * Shorthand method for creating and appending an HTML element
       *
       * @param  {String} tagName    The tag name (e.g. "div")
       * @param  {int|null} attrCount  The number of attributes (or `null` if not known)
       * @param  {int|null} childCount The number of child nodes (or `null` if not known)
       */
      e: function(tagName, attrs, key, ownerComponent, childCount, flags, props) {
        var child = this.___appendChild(
          new VElement(
            tagName,
            attrs,
            key,
            ownerComponent,
            childCount,
            flags,
            props
          )
        );
        if (childCount === 0) {
          return this.___finishChild();
        } else {
          return child;
        }
      },
      /**
       * Shorthand method for creating and appending a static node. The provided node is automatically cloned
       * using a shallow clone since it will be mutated as a result of setting `nextSibling` and `parentNode`.
       *
       * @param  {String} value The value for the new Comment node
       */
      n: function(node, ownerComponent) {
        node = node.___cloneNode();
        node.___ownerComponent = ownerComponent;
        this.___appendChild(node);
        return this.___finishChild();
      },
      ___actualize: function(host, parentNamespaceURI) {
        var tagName = this.___nodeName;
        var attributes = this.___attributes;
        var namespaceURI = DEFAULT_NS[tagName] || parentNamespaceURI || NS_HTML;
        var flags = this.___flags;
        var el = (host.ownerDocument || host).createElementNS(
          namespaceURI,
          tagName
        );
        if (flags & FLAG_CUSTOM_ELEMENT) {
          assign(el, attributes);
        } else {
          for (var attrName in attributes) {
            var attrValue = normalizeValue(attributes[attrName]);
            if (attrValue !== void 0) {
              if (attrName == ATTR_XLINK_HREF) {
                el.setAttributeNS(NS_XLINK, ATTR_HREF, attrValue);
              } else {
                el.setAttribute(attrName, attrValue);
              }
            }
          }
          if (tagName === "textarea") {
            el.defaultValue = this.___valueInternal;
          }
        }
        vElementByDOMNode.set(el, this);
        return el;
      }
    };
    inherit(VElement, VNode);
    VElementClone.prototype = VElement.prototype;
    function virtualizeElement(node, virtualizeChildNodes, ownerComponent) {
      var attributes = node.attributes;
      var attrCount = attributes.length;
      var attrs = null;
      var props = null;
      if (attrCount) {
        attrs = {};
        for (var i = 0; i < attrCount; i++) {
          var attr = attributes[i];
          var attrName = attr.name;
          if (!xmlnsRegExp.test(attrName)) {
            if (attrName === "data-marko") {
              props = componentsUtil.___getMarkoPropsFromEl(node);
            } else if (attr.namespaceURI === NS_XLINK) {
              attrs[ATTR_XLINK_HREF] = attr.value;
            } else {
              attrs[attrName] = attr.value;
            }
          }
        }
      }
      var tagName = node.nodeName;
      if (node.namespaceURI === NS_HTML) {
        tagName = tagName.toLowerCase();
      }
      var vdomEl = new VElement(
        tagName,
        attrs,
        null,
        ownerComponent,
        0,
        0,
        props
      );
      if (vdomEl.___nodeName === "textarea") {
        vdomEl.___valueInternal = node.value;
      } else if (virtualizeChildNodes) {
        virtualizeChildNodes(node, vdomEl, ownerComponent);
      }
      return vdomEl;
    }
    VElement.___virtualize = virtualizeElement;
    VElement.___morphAttrs = function(fromEl, vFromEl, toEl) {
      var fromFlags = vFromEl.___flags;
      var toFlags = toEl.___flags;
      var attrs = toEl.___attributes;
      if (toFlags & FLAG_CUSTOM_ELEMENT) {
        return assign(fromEl, attrs);
      }
      var props = toEl.___properties;
      var attrName;
      var oldAttrs = vFromEl.___attributes;
      if (oldAttrs === attrs) {
        return;
      }
      var attrValue;
      if (toFlags & FLAG_SIMPLE_ATTRS && fromFlags & FLAG_SIMPLE_ATTRS) {
        if (oldAttrs["class"] !== (attrValue = attrs["class"])) {
          if (attrValue) {
            fromEl.className = attrValue;
          } else {
            fromEl.removeAttribute("class");
          }
        }
        if (oldAttrs.id !== (attrValue = attrs.id)) {
          if (attrValue) {
            fromEl.id = attrValue;
          } else {
            fromEl.removeAttribute("id");
          }
        }
        if (oldAttrs.style !== (attrValue = attrs.style)) {
          if (attrValue) {
            fromEl.style.cssText = attrValue;
          } else {
            fromEl.removeAttribute("style");
          }
        }
        return;
      }
      var preserve = props && props.pa || EMPTY_OBJECT;
      var specialAttrs = specialElHandlers[toEl.___nodeName] || EMPTY_OBJECT;
      var specialAttr;
      for (attrName in attrs) {
        if (!preserve[attrName] && normalizeValue(oldAttrs[attrName]) !== (attrValue = normalizeValue(attrs[attrName]))) {
          if (specialAttr = specialAttrs[attrName]) {
            specialAttr(fromEl, attrValue);
          } else if (attrName === ATTR_XLINK_HREF) {
            if (attrValue === void 0) {
              fromEl.removeAttributeNS(NS_XLINK, ATTR_HREF);
            } else {
              fromEl.setAttributeNS(NS_XLINK, ATTR_HREF, attrValue);
            }
          } else if (attrValue === void 0) {
            fromEl.removeAttribute(attrName);
          } else {
            fromEl.setAttribute(attrName, attrValue);
          }
        }
      }
      if (toEl.___key === null || fromFlags & FLAG_SPREAD_ATTRS) {
        for (attrName in oldAttrs) {
          if (!(attrName in attrs)) {
            if (specialAttr = specialAttrs[attrName]) {
              specialAttr(fromEl, void 0);
            } else if (attrName === ATTR_XLINK_HREF) {
              fromEl.removeAttributeNS(ATTR_XLINK_HREF, ATTR_HREF);
            } else {
              fromEl.removeAttribute(attrName);
            }
          }
        }
      }
    };
    module.exports = VElement;
  }
});

// node_modules/marko/src/runtime/vdom/morphdom/helpers.js
var require_helpers = __commonJS({
  "node_modules/marko/src/runtime/vdom/morphdom/helpers.js"(exports) {
    function insertBefore(node, referenceNode, parentNode) {
      if (node.insertInto) {
        return node.insertInto(parentNode, referenceNode);
      }
      return parentNode.insertBefore(
        node,
        referenceNode && referenceNode.startNode || referenceNode
      );
    }
    function insertAfter(node, referenceNode, parentNode) {
      return insertBefore(
        node,
        referenceNode && referenceNode.nextSibling,
        parentNode
      );
    }
    function nextSibling(node) {
      var next = node.nextSibling;
      var fragment = next && next.fragment;
      if (fragment) {
        return next === fragment.startNode ? fragment : null;
      }
      return next;
    }
    function firstChild(node) {
      var next = node.firstChild;
      return next && next.fragment || next;
    }
    function removeChild(node) {
      if (node.remove) node.remove();
      else node.parentNode.removeChild(node);
    }
    exports.___insertBefore = insertBefore;
    exports.___insertAfter = insertAfter;
    exports.___nextSibling = nextSibling;
    exports.___firstChild = firstChild;
    exports.___removeChild = removeChild;
  }
});

// node_modules/marko/src/runtime/vdom/morphdom/fragment.js
var require_fragment = __commonJS({
  "node_modules/marko/src/runtime/vdom/morphdom/fragment.js"(exports) {
    var helpers = require_helpers();
    var insertBefore = helpers.___insertBefore;
    var fragmentPrototype = {
      nodeType: 12,
      get firstChild() {
        var firstChild = this.startNode.nextSibling;
        return firstChild === this.endNode ? void 0 : firstChild;
      },
      get lastChild() {
        var lastChild = this.endNode.previousSibling;
        return lastChild === this.startNode ? void 0 : lastChild;
      },
      get parentNode() {
        var parentNode = this.startNode.parentNode;
        return parentNode === this.detachedContainer ? void 0 : parentNode;
      },
      get namespaceURI() {
        return this.startNode.parentNode.namespaceURI;
      },
      get nextSibling() {
        return this.endNode.nextSibling;
      },
      get nodes() {
        if ("MARKO_DEBUG") {
          if (this.___markersRemovedError) {
            throw this.___markersRemovedError("Cannot get fragment nodes.");
          }
        }
        var nodes = [];
        var current = this.startNode;
        while (current !== this.endNode) {
          nodes.push(current);
          current = current.nextSibling;
        }
        nodes.push(current);
        return nodes;
      },
      insertBefore: function(newChildNode, referenceNode) {
        var actualReference = referenceNode == null ? this.endNode : referenceNode;
        return insertBefore(
          newChildNode,
          actualReference,
          this.startNode.parentNode
        );
      },
      insertInto: function(newParentNode, referenceNode) {
        this.nodes.forEach(function(node) {
          insertBefore(node, referenceNode, newParentNode);
        }, this);
        return this;
      },
      remove: function() {
        this.nodes.forEach(function(node) {
          this.detachedContainer.appendChild(node);
        }, this);
      }
    };
    function createFragmentNode(startNode, nextNode, parentNode) {
      var fragment = Object.create(fragmentPrototype);
      var isRoot = startNode && startNode.ownerDocument === startNode.parentNode;
      fragment.startNode = isRoot ? document.createComment("") : document.createTextNode("");
      fragment.endNode = isRoot ? document.createComment("") : document.createTextNode("");
      fragment.startNode.fragment = fragment;
      fragment.endNode.fragment = fragment;
      var detachedContainer = fragment.detachedContainer = document.createDocumentFragment();
      parentNode = parentNode || startNode && startNode.parentNode || detachedContainer;
      insertBefore(fragment.startNode, startNode, parentNode);
      insertBefore(fragment.endNode, nextNode, parentNode);
      return fragment;
    }
    function beginFragmentNode(startNode, parentNode) {
      var fragment = createFragmentNode(startNode, null, parentNode);
      fragment.___finishFragment = function(nextNode) {
        fragment.___finishFragment = null;
        insertBefore(
          fragment.endNode,
          nextNode,
          parentNode || startNode.parentNode
        );
      };
      return fragment;
    }
    exports.___createFragmentNode = createFragmentNode;
    exports.___beginFragmentNode = beginFragmentNode;
  }
});

// node_modules/marko/src/runtime/vdom/VFragment.js
var require_VFragment = __commonJS({
  "node_modules/marko/src/runtime/vdom/VFragment.js"(exports, module) {
    var inherit = require_inherit();
    var domData = require_dom_data();
    var keysByDOMNode = domData.___keyByDOMNode;
    var vElementByDOMNode = domData.___vElementByDOMNode;
    var createFragmentNode = require_fragment().___createFragmentNode;
    var VNode = require_VNode();
    function VFragment(key, ownerComponent, preserve) {
      this.___VNode(null, ownerComponent);
      this.___key = key;
      this.___preserve = preserve;
    }
    VFragment.prototype = {
      ___nodeType: 12,
      ___actualize: function() {
        var fragment = createFragmentNode();
        keysByDOMNode.set(fragment, this.___key);
        vElementByDOMNode.set(fragment, this);
        return fragment;
      }
    };
    inherit(VFragment, VNode);
    module.exports = VFragment;
  }
});

// node_modules/marko/src/runtime/vdom/VText.js
var require_VText = __commonJS({
  "node_modules/marko/src/runtime/vdom/VText.js"(exports, module) {
    var inherit = require_inherit();
    var VNode = require_VNode();
    function VText(value, ownerComponent) {
      this.___VNode(-1, ownerComponent);
      this.___nodeValue = value;
    }
    VText.prototype = {
      ___Text: true,
      ___nodeType: 3,
      ___actualize: function(host) {
        return (host.ownerDocument || host).createTextNode(this.___nodeValue);
      },
      ___cloneNode: function() {
        return new VText(this.___nodeValue);
      }
    };
    inherit(VText, VNode);
    module.exports = VText;
  }
});

// node_modules/marko/src/runtime/vdom/vdom.js
var require_vdom = __commonJS({
  "node_modules/marko/src/runtime/vdom/vdom.js"(exports) {
    var parseHTML = require_parse_html();
    var VComment = require_VComment();
    var VComponent = require_VComponent();
    var VDocumentFragment = require_VDocumentFragment();
    var VElement = require_VElement();
    var VFragment = require_VFragment();
    var VNode = require_VNode();
    var VText = require_VText();
    var specialHtmlRegexp = /[&<]/;
    function virtualizeChildNodes(node, vdomParent, ownerComponent) {
      var curChild = node.firstChild;
      while (curChild) {
        vdomParent.___appendChild(virtualize(curChild, ownerComponent));
        curChild = curChild.nextSibling;
      }
    }
    function virtualize(node, ownerComponent) {
      switch (node.nodeType) {
        case 1:
          return VElement.___virtualize(node, virtualizeChildNodes, ownerComponent);
        case 3:
          return new VText(node.nodeValue, ownerComponent);
        case 8:
          return new VComment(node.nodeValue, ownerComponent);
        case 11:
          var vdomDocFragment = new VDocumentFragment();
          virtualizeChildNodes(node, vdomDocFragment, ownerComponent);
          return vdomDocFragment;
      }
    }
    function virtualizeHTML(html, ownerComponent) {
      if (!specialHtmlRegexp.test(html)) {
        return new VText(html, ownerComponent);
      }
      var vdomFragment = new VDocumentFragment();
      var curChild = parseHTML(html);
      var virtualized;
      while (curChild) {
        virtualized = virtualize(curChild, ownerComponent);
        if (virtualized) vdomFragment.___appendChild(virtualized);
        curChild = curChild.nextSibling;
      }
      return vdomFragment;
    }
    var Node_prototype = VNode.prototype;
    Node_prototype.t = function(value) {
      var type = typeof value;
      var vdomNode;
      if (type !== "string") {
        if (value == null) {
          value = "";
        } else if (type === "object") {
          if (value.toHTML) {
            vdomNode = virtualizeHTML(value.toHTML());
          }
        }
      }
      this.___appendChild(vdomNode || new VText(value.toString()));
      return this.___finishChild();
    };
    Node_prototype.___appendDocumentFragment = function() {
      return this.___appendChild(new VDocumentFragment());
    };
    exports.___VComment = VComment;
    exports.___VDocumentFragment = VDocumentFragment;
    exports.___VElement = VElement;
    exports.___VText = VText;
    exports.___VComponent = VComponent;
    exports.___VFragment = VFragment;
    exports.___virtualize = virtualize;
    exports.___virtualizeHTML = virtualizeHTML;
  }
});

export {
  require_copyProps,
  require_inherit,
  require_helpers,
  require_fragment,
  require_vdom
};
//# sourceMappingURL=chunk-PWCIM3WU.js.map
