import {
  require_RenderResult,
  require_createOut,
  require_dom_insert,
  require_index_browser,
  require_morphdom,
  require_src
} from "./chunk-DDL5ICIO.js";
import {
  require_inherit
} from "./chunk-PWCIM3WU.js";
import {
  require_ComponentsContext
} from "./chunk-GIKHVMKU.js";
import {
  require_extend
} from "./chunk-3BN66U4C.js";
import {
  require_complain
} from "./chunk-AUY6IS4O.js";
import {
  require_event_delegation
} from "./chunk-CNQJXT2F.js";
import {
  require_dom_data,
  require_index_browser as require_index_browser2
} from "./chunk-XOFOD672.js";
import {
  __commonJS
} from "./chunk-VUNV25KB.js";

// node_modules/listener-tracker/lib/listener-tracker.js
var require_listener_tracker = __commonJS({
  "node_modules/listener-tracker/lib/listener-tracker.js"(exports, module) {
    var INDEX_EVENT = 0;
    var INDEX_USER_LISTENER = 1;
    var INDEX_WRAPPED_LISTENER = 2;
    var DESTROY = "destroy";
    function isNonEventEmitter(target) {
      return !target.once;
    }
    function EventEmitterWrapper(target) {
      this.$__target = target;
      this.$__listeners = [];
      this.$__subscribeTo = null;
    }
    EventEmitterWrapper.prototype = {
      $__remove: function(test, testWrapped) {
        var target = this.$__target;
        var listeners = this.$__listeners;
        this.$__listeners = listeners.filter(function(curListener) {
          var curEvent = curListener[INDEX_EVENT];
          var curListenerFunc = curListener[INDEX_USER_LISTENER];
          var curWrappedListenerFunc = curListener[INDEX_WRAPPED_LISTENER];
          if (testWrapped) {
            if (curWrappedListenerFunc && test(curEvent, curWrappedListenerFunc)) {
              target.removeListener(curEvent, curWrappedListenerFunc);
              return false;
            }
          } else if (test(curEvent, curListenerFunc)) {
            target.removeListener(curEvent, curWrappedListenerFunc || curListenerFunc);
            return false;
          }
          return true;
        });
        var subscribeTo = this.$__subscribeTo;
        if (!this.$__listeners.length && subscribeTo) {
          var self = this;
          var subscribeToList = subscribeTo.$__subscribeToList;
          subscribeTo.$__subscribeToList = subscribeToList.filter(function(cur) {
            return cur !== self;
          });
        }
      },
      on: function(event, listener) {
        this.$__target.on(event, listener);
        this.$__listeners.push([event, listener]);
        return this;
      },
      once: function(event, listener) {
        var self = this;
        var wrappedListener = function() {
          self.$__remove(
            function(event2, listenerFunc) {
              return wrappedListener === listenerFunc;
            },
            true
            /* We are removing the wrapped listener */
          );
          listener.apply(this, arguments);
        };
        this.$__target.once(event, wrappedListener);
        this.$__listeners.push([event, listener, wrappedListener]);
        return this;
      },
      removeListener: function(event, listener) {
        if (typeof event === "function") {
          listener = event;
          event = null;
        }
        if (listener && event) {
          this.$__remove(function(curEvent, curListener) {
            return event === curEvent && listener === curListener;
          });
        } else if (listener) {
          this.$__remove(function(curEvent, curListener) {
            return listener === curListener;
          });
        } else if (event) {
          this.removeAllListeners(event);
        }
        return this;
      },
      removeAllListeners: function(event) {
        var listeners = this.$__listeners;
        var target = this.$__target;
        if (event) {
          this.$__remove(function(curEvent, curListener) {
            return event === curEvent;
          });
        } else {
          for (var i = listeners.length - 1; i >= 0; i--) {
            var cur = listeners[i];
            target.removeListener(cur[INDEX_EVENT], cur[INDEX_USER_LISTENER]);
          }
          this.$__listeners.length = 0;
        }
        return this;
      }
    };
    function EventEmitterAdapter(target) {
      this.$__target = target;
    }
    EventEmitterAdapter.prototype = {
      on: function(event, listener) {
        this.$__target.addEventListener(event, listener);
        return this;
      },
      once: function(event, listener) {
        var self = this;
        var onceListener = function() {
          self.$__target.removeEventListener(event, onceListener);
          listener();
        };
        this.$__target.addEventListener(event, onceListener);
        return this;
      },
      removeListener: function(event, listener) {
        this.$__target.removeEventListener(event, listener);
        return this;
      }
    };
    function SubscriptionTracker() {
      this.$__subscribeToList = [];
    }
    SubscriptionTracker.prototype = {
      subscribeTo: function(target, options) {
        var addDestroyListener = !options || options.addDestroyListener !== false;
        var wrapper;
        var nonEE;
        var subscribeToList = this.$__subscribeToList;
        for (var i = 0, len = subscribeToList.length; i < len; i++) {
          var cur = subscribeToList[i];
          if (cur.$__target === target) {
            wrapper = cur;
            break;
          }
        }
        if (!wrapper) {
          if (isNonEventEmitter(target)) {
            nonEE = new EventEmitterAdapter(target);
          }
          wrapper = new EventEmitterWrapper(nonEE || target);
          if (addDestroyListener && !nonEE) {
            wrapper.once(DESTROY, function() {
              wrapper.removeAllListeners();
              for (var i2 = subscribeToList.length - 1; i2 >= 0; i2--) {
                if (subscribeToList[i2].$__target === target) {
                  subscribeToList.splice(i2, 1);
                  break;
                }
              }
            });
          }
          wrapper.$__subscribeTo = this;
          subscribeToList.push(wrapper);
        }
        return wrapper;
      },
      removeAllListeners: function(target, event) {
        var subscribeToList = this.$__subscribeToList;
        var i;
        if (target) {
          for (i = subscribeToList.length - 1; i >= 0; i--) {
            var cur = subscribeToList[i];
            if (cur.$__target === target) {
              cur.removeAllListeners(event);
              if (!cur.$__listeners.length) {
                subscribeToList.splice(i, 1);
              }
              break;
            }
          }
        } else {
          for (i = subscribeToList.length - 1; i >= 0; i--) {
            subscribeToList[i].removeAllListeners();
          }
          subscribeToList.length = 0;
        }
      }
    };
    exports = module.exports = SubscriptionTracker;
    exports.wrap = function(targetEventEmitter) {
      var nonEE;
      var wrapper;
      if (isNonEventEmitter(targetEventEmitter)) {
        nonEE = new EventEmitterAdapter(targetEventEmitter);
      }
      wrapper = new EventEmitterWrapper(nonEE || targetEventEmitter);
      if (!nonEE) {
        targetEventEmitter.once(DESTROY, function() {
          wrapper.$__listeners.length = 0;
        });
      }
      return wrapper;
    };
    exports.createTracker = function() {
      return new SubscriptionTracker();
    };
  }
});

// node_modules/marko/src/runtime/components/update-manager.js
var require_update_manager = __commonJS({
  "node_modules/marko/src/runtime/components/update-manager.js"(exports) {
    "use strict";
    var updatesScheduled = false;
    var batchStack = [];
    var unbatchedQueue = [];
    var setImmediate = require_index_browser().___setImmediate;
    function updateUnbatchedComponents() {
      if (unbatchedQueue.length) {
        try {
          updateComponents(unbatchedQueue);
        } finally {
          updatesScheduled = false;
        }
      }
    }
    function scheduleUpdates() {
      if (updatesScheduled) {
        return;
      }
      updatesScheduled = true;
      setImmediate(updateUnbatchedComponents);
    }
    function updateComponents(queue) {
      for (var i = 0; i < queue.length; i++) {
        var component = queue[i];
        component.___update();
      }
      queue.length = 0;
    }
    function batchUpdate(func) {
      var batch = [];
      batchStack.push(batch);
      try {
        func();
      } finally {
        try {
          updateComponents(batch);
        } finally {
          batchStack.length--;
        }
      }
    }
    function queueComponentUpdate(component) {
      var batchStackLen = batchStack.length;
      if (batchStackLen) {
        batchStack[batchStackLen - 1].push(component);
      } else {
        scheduleUpdates();
        unbatchedQueue.push(component);
      }
    }
    exports.___queueComponentUpdate = queueComponentUpdate;
    exports.___batchUpdate = batchUpdate;
  }
});

// node_modules/marko/src/runtime/components/Component.js
var require_Component = __commonJS({
  "node_modules/marko/src/runtime/components/Component.js"(exports, module) {
    "use strict";
    var complain = require_complain();
    var EventEmitter = require_src();
    var SubscriptionTracker = require_listener_tracker();
    var inherit = require_inherit();
    var componentsUtil = require_index_browser2();
    var componentLookup = componentsUtil.___componentLookup;
    var destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;
    var defaultCreateOut = require_createOut();
    var domInsert = require_dom_insert();
    var RenderResult = require_RenderResult();
    var morphdom = require_morphdom();
    var getComponentsContext = require_ComponentsContext().___getComponentsContext;
    var domData = require_dom_data();
    var eventDelegation = require_event_delegation();
    var updateManager = require_update_manager();
    var componentsByDOMNode = domData.___componentByDOMNode;
    var keyedElementsByComponentId = domData.___ssrKeyedElementsByComponentId;
    var CONTEXT_KEY = "__subtree_context__";
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var slice = Array.prototype.slice;
    var COMPONENT_SUBSCRIBE_TO_OPTIONS;
    var NON_COMPONENT_SUBSCRIBE_TO_OPTIONS = {
      addDestroyListener: false
    };
    var emit = EventEmitter.prototype.emit;
    var ELEMENT_NODE = 1;
    function removeListener(removeEventListenerHandle) {
      removeEventListenerHandle();
    }
    function walkFragments(fragment) {
      var node;
      while (fragment) {
        node = fragment.firstChild;
        if (!node) {
          break;
        }
        fragment = node.fragment;
      }
      return node;
    }
    function handleCustomEventWithMethodListener(component, targetMethodName, args, extraArgs) {
      args.push(component);
      if (extraArgs) {
        args = extraArgs.concat(args);
      }
      var targetComponent = componentLookup[component.___scope];
      var targetMethod = typeof targetMethodName === "function" ? targetMethodName : targetComponent[targetMethodName];
      if (!targetMethod) {
        throw Error("Method not found: " + targetMethodName);
      }
      targetMethod.apply(targetComponent, args);
    }
    function resolveKeyHelper(key, index) {
      return index ? key + "_" + index : key;
    }
    function resolveComponentIdHelper(component, key, index) {
      return component.id + "-" + resolveKeyHelper(key, index);
    }
    function processUpdateHandlers(component, stateChanges, oldState) {
      var handlerMethod;
      var handlers;
      for (var propName in stateChanges) {
        if (hasOwnProperty.call(stateChanges, propName)) {
          var handlerMethodName = "update_" + propName;
          handlerMethod = component[handlerMethodName];
          if (handlerMethod) {
            (handlers || (handlers = [])).push([propName, handlerMethod]);
          } else {
            return;
          }
        }
      }
      if (handlers) {
        handlers.forEach(function(handler) {
          var propertyName = handler[0];
          handlerMethod = handler[1];
          var newValue = stateChanges[propertyName];
          var oldValue = oldState[propertyName];
          handlerMethod.call(component, newValue, oldValue);
        });
        component.___emitUpdate();
        component.___reset();
      }
      return true;
    }
    function checkInputChanged(existingComponent, oldInput, newInput) {
      if (oldInput != newInput) {
        if (oldInput == null || newInput == null) {
          return true;
        }
        var oldKeys = Object.keys(oldInput);
        var newKeys = Object.keys(newInput);
        var len = oldKeys.length;
        if (len !== newKeys.length) {
          return true;
        }
        for (var i = len; i--; ) {
          var key = oldKeys[i];
          if (!(key in newInput && oldInput[key] === newInput[key])) {
            return true;
          }
        }
      }
      return false;
    }
    var componentProto;
    function Component(id) {
      EventEmitter.call(this);
      this.id = id;
      this.___state = null;
      this.___rootNode = null;
      this.___subscriptions = null;
      this.___domEventListenerHandles = null;
      this.___bubblingDomEvents = null;
      this.___customEvents = null;
      this.___scope = null;
      this.___renderInput = null;
      this.___input = void 0;
      this.___mounted = false;
      this.___global = void 0;
      this.___destroyed = false;
      this.___updateQueued = false;
      this.___dirty = false;
      this.___settingInput = false;
      this.___host = void 0;
      var ssrKeyedElements = keyedElementsByComponentId[id];
      if (ssrKeyedElements) {
        this.___keyedElements = ssrKeyedElements;
        delete keyedElementsByComponentId[id];
      } else {
        this.___keyedElements = {};
      }
    }
    Component.prototype = componentProto = {
      ___isComponent: true,
      subscribeTo: function(target) {
        if (!target) {
          throw TypeError();
        }
        var subscriptions = this.___subscriptions || (this.___subscriptions = new SubscriptionTracker());
        var subscribeToOptions = target.___isComponent ? COMPONENT_SUBSCRIBE_TO_OPTIONS : NON_COMPONENT_SUBSCRIBE_TO_OPTIONS;
        return subscriptions.subscribeTo(target, subscribeToOptions);
      },
      emit: function(eventType) {
        var customEvents = this.___customEvents;
        var target;
        if (customEvents && (target = customEvents[eventType])) {
          var targetMethodName = target[0];
          var isOnce = target[1];
          var extraArgs = target[2];
          var args = slice.call(arguments, 1);
          handleCustomEventWithMethodListener(
            this,
            targetMethodName,
            args,
            extraArgs
          );
          if (isOnce) {
            delete customEvents[eventType];
          }
        }
        return emit.apply(this, arguments);
      },
      getElId: function(key, index) {
        if (!key) {
          return this.id;
        }
        return resolveComponentIdHelper(this, key, index);
      },
      getEl: function(key, index) {
        if (key) {
          var resolvedKey = resolveKeyHelper(key, index);
          var keyedElement = this.___keyedElements["@" + resolvedKey];
          if (keyedElement && keyedElement.nodeType === 12) {
            if ("MARKO_DEBUG") {
              complain(
                "Accessing the elements of a child component using 'component.getEl' is deprecated."
              );
            }
            return walkFragments(keyedElement);
          }
          return keyedElement;
        } else {
          return this.el;
        }
      },
      getEls: function(key) {
        key = key + "[]";
        var els = [];
        var i = 0;
        var el;
        while (el = this.getEl(key, i)) {
          els.push(el);
          i++;
        }
        return els;
      },
      getComponent: function(key, index) {
        var rootNode = this.___keyedElements["@" + resolveKeyHelper(key, index)];
        if (/\[\]$/.test(key)) {
          if ("MARKO_DEBUG") {
            complain(
              "A repeated key[] was passed to getComponent. Use a non-repeating key if there is only one of these components."
            );
          }
          rootNode = rootNode && rootNode[Object.keys(rootNode)[0]];
        }
        return rootNode && componentsByDOMNode.get(rootNode);
      },
      getComponents: function(key) {
        var lookup = this.___keyedElements["@" + key + "[]"];
        return lookup ? Object.keys(lookup).map(function(key2) {
          return componentsByDOMNode.get(lookup[key2]);
        }).filter(Boolean) : [];
      },
      destroy: function() {
        if (this.___destroyed) {
          return;
        }
        var root = this.___rootNode;
        this.___destroyShallow();
        var nodes = root.nodes;
        nodes.forEach(function(node) {
          destroyNodeRecursive(node);
          if (eventDelegation.___handleNodeDetach(node) !== false) {
            node.parentNode.removeChild(node);
          }
        });
        root.detached = true;
        delete componentLookup[this.id];
        this.___keyedElements = {};
      },
      ___destroyShallow: function() {
        if (this.___destroyed) {
          return;
        }
        this.___emitDestroy();
        this.___destroyed = true;
        componentsByDOMNode.set(this.___rootNode, void 0);
        this.___rootNode = null;
        this.___removeDOMEventListeners();
        var subscriptions = this.___subscriptions;
        if (subscriptions) {
          subscriptions.removeAllListeners();
          this.___subscriptions = null;
        }
      },
      isDestroyed: function() {
        return this.___destroyed;
      },
      get state() {
        return this.___state;
      },
      set state(newState) {
        var state = this.___state;
        if (!state && !newState) {
          return;
        }
        if (!state) {
          state = this.___state = new this.___State(this);
        }
        state.___replace(newState || {});
        if (state.___dirty) {
          this.___queueUpdate();
        }
        if (!newState) {
          this.___state = null;
        }
      },
      setState: function(name, value) {
        var state = this.___state;
        if (!state) {
          state = this.___state = new this.___State(this);
        }
        if (typeof name == "object") {
          var newState = name;
          for (var k in newState) {
            if (hasOwnProperty.call(newState, k)) {
              state.___set(
                k,
                newState[k],
                true
                /* ensure:true */
              );
            }
          }
        } else {
          state.___set(
            name,
            value,
            true
            /* ensure:true */
          );
        }
      },
      setStateDirty: function(name, value) {
        var state = this.___state;
        if (arguments.length == 1) {
          value = state[name];
        }
        state.___set(
          name,
          value,
          true,
          true
        );
      },
      replaceState: function(newState) {
        this.___state.___replace(newState);
      },
      get input() {
        return this.___input;
      },
      set input(newInput) {
        if (this.___settingInput) {
          this.___input = newInput;
        } else {
          this.___setInput(newInput);
        }
      },
      ___setInput: function(newInput, onInput, out) {
        onInput = onInput || this.onInput;
        var updatedInput;
        var oldInput = this.___input;
        this.___input = void 0;
        this.___context = out && out[CONTEXT_KEY] || this.___context;
        if (onInput) {
          this.___settingInput = true;
          updatedInput = onInput.call(this, newInput || {}, out);
          this.___settingInput = false;
        }
        newInput = this.___renderInput = updatedInput || newInput;
        if (this.___dirty = checkInputChanged(this, oldInput, newInput)) {
          this.___queueUpdate();
        }
        if (this.___input === void 0) {
          this.___input = newInput;
          if (newInput && newInput.$global) {
            this.___global = newInput.$global;
          }
        }
        return newInput;
      },
      forceUpdate: function() {
        this.___dirty = true;
        this.___queueUpdate();
      },
      ___queueUpdate: function() {
        if (!this.___updateQueued) {
          this.___updateQueued = true;
          updateManager.___queueComponentUpdate(this);
        }
      },
      update: function() {
        if (this.___destroyed === true || this.___isDirty === false) {
          return;
        }
        var input = this.___input;
        var state = this.___state;
        if (this.___dirty === false && state !== null && state.___dirty === true) {
          if (processUpdateHandlers(this, state.___changes, state.___old, state)) {
            state.___dirty = false;
          }
        }
        if (this.___isDirty === true) {
          if (this.shouldUpdate(input, state) !== false) {
            this.___scheduleRerender();
          }
        }
        this.___reset();
      },
      get ___isDirty() {
        return this.___dirty === true || this.___state !== null && this.___state.___dirty === true;
      },
      ___reset: function() {
        this.___dirty = false;
        this.___updateQueued = false;
        this.___renderInput = null;
        var state = this.___state;
        if (state) {
          state.___reset();
        }
      },
      shouldUpdate: function() {
        return true;
      },
      ___scheduleRerender: function() {
        var self = this;
        var renderer = self.___renderer;
        if (!renderer) {
          throw TypeError();
        }
        var input = this.___renderInput || this.___input;
        updateManager.___batchUpdate(function() {
          self.___rerender(input, false).afterInsert(self.___host);
        });
        this.___reset();
      },
      ___rerender: function(input, isHydrate) {
        var host = this.___host;
        var globalData = this.___global;
        var rootNode = this.___rootNode;
        var renderer = this.___renderer;
        var createOut = renderer.createOut || defaultCreateOut;
        var out = createOut(globalData);
        out.sync();
        out.___host = this.___host;
        out[CONTEXT_KEY] = this.___context;
        var componentsContext = getComponentsContext(out);
        var globalComponentsContext = componentsContext.___globalContext;
        globalComponentsContext.___rerenderComponent = this;
        globalComponentsContext.___isHydrate = isHydrate;
        renderer(input, out);
        var result = new RenderResult(out);
        var targetNode = out.___getOutput().___firstChild;
        morphdom(rootNode, targetNode, host, componentsContext);
        return result;
      },
      ___detach: function() {
        var root = this.___rootNode;
        root.remove();
        return root;
      },
      ___removeDOMEventListeners: function() {
        var eventListenerHandles = this.___domEventListenerHandles;
        if (eventListenerHandles) {
          eventListenerHandles.forEach(removeListener);
          this.___domEventListenerHandles = null;
        }
      },
      get ___rawState() {
        var state = this.___state;
        return state && state.___raw;
      },
      ___setCustomEvents: function(customEvents, scope) {
        var finalCustomEvents = this.___customEvents = {};
        this.___scope = scope;
        customEvents.forEach(function(customEvent) {
          var eventType = customEvent[0];
          var targetMethodName = customEvent[1];
          var isOnce = customEvent[2];
          var extraArgs = customEvent[3];
          if (targetMethodName) {
            finalCustomEvents[eventType] = [targetMethodName, isOnce, extraArgs];
          }
        });
      },
      get el() {
        return walkFragments(this.___rootNode);
      },
      get els() {
        if ("MARKO_DEBUG") {
          complain(
            'The "this.els" attribute is deprecated. Please use "this.getEls(key)" instead.'
          );
        }
        return (this.___rootNode ? this.___rootNode.nodes : []).filter(
          function(el) {
            return el.nodeType === ELEMENT_NODE;
          }
        );
      },
      ___emit: emit,
      ___emitCreate(input, out) {
        this.onCreate && this.onCreate(input, out);
        this.___emit("create", input, out);
      },
      ___emitRender(out) {
        this.onRender && this.onRender(out);
        this.___emit("render", out);
      },
      ___emitUpdate() {
        this.onUpdate && this.onUpdate();
        this.___emit("update");
      },
      ___emitMount() {
        this.onMount && this.onMount();
        this.___emit("mount");
      },
      ___emitDestroy() {
        this.onDestroy && this.onDestroy();
        this.___emit("destroy");
      }
    };
    componentProto.elId = componentProto.getElId;
    componentProto.___update = componentProto.update;
    componentProto.___destroy = componentProto.destroy;
    domInsert(
      componentProto,
      function getEl(component) {
        return component.___detach();
      },
      function afterInsert(component) {
        return component;
      }
    );
    inherit(Component, EventEmitter);
    module.exports = Component;
  }
});

// node_modules/marko/src/runtime/components/State.js
var require_State = __commonJS({
  "node_modules/marko/src/runtime/components/State.js"(exports, module) {
    var extend = require_extend();
    function ensure(state, propertyName) {
      var proto = state.constructor.prototype;
      if (!(propertyName in proto)) {
        Object.defineProperty(proto, propertyName, {
          get: function() {
            return this.___raw[propertyName];
          },
          set: function(value) {
            this.___set(
              propertyName,
              value,
              false
              /* ensure:false */
            );
          }
        });
      }
    }
    function State(component) {
      this.___component = component;
      this.___raw = {};
      this.___dirty = false;
      this.___old = null;
      this.___changes = null;
      this.___forced = null;
      Object.seal(this);
    }
    State.prototype = {
      ___reset: function() {
        this.___dirty = false;
        this.___old = null;
        this.___changes = null;
        this.___forced = null;
      },
      ___replace: function(newState) {
        var key;
        var rawState = this.___raw;
        for (key in rawState) {
          if (!(key in newState)) {
            this.___set(
              key,
              void 0,
              false,
              false
            );
          }
        }
        for (key in newState) {
          this.___set(
            key,
            newState[key],
            true,
            false
          );
        }
      },
      ___set: function(name, value, shouldEnsure, forceDirty) {
        var rawState = this.___raw;
        if (shouldEnsure) {
          ensure(this, name);
        }
        if (forceDirty) {
          var forcedDirtyState = this.___forced || (this.___forced = {});
          forcedDirtyState[name] = true;
        } else if (rawState[name] === value) {
          return;
        }
        if (!this.___dirty) {
          this.___dirty = true;
          this.___old = rawState;
          this.___raw = rawState = extend({}, rawState);
          this.___changes = {};
          this.___component.___queueUpdate();
        }
        this.___changes[name] = value;
        if (value === void 0) {
          delete rawState[name];
        } else {
          rawState[name] = value;
        }
      },
      toJSON: function() {
        return this.___raw;
      }
    };
    module.exports = State;
  }
});

// node_modules/marko/src/runtime/components/defineComponent.js
var require_defineComponent = __commonJS({
  "node_modules/marko/src/runtime/components/defineComponent.js"(exports, module) {
    var inherit = require_inherit();
    var BaseComponent = require_Component();
    var BaseState = require_State();
    module.exports = function defineComponent(def, renderer) {
      if (def.___isComponent) {
        return def;
      }
      var ComponentClass = function() {
      };
      var proto;
      var type = typeof def;
      if (type == "function") {
        proto = def.prototype;
      } else if (type == "object") {
        proto = def;
      } else {
        throw TypeError();
      }
      ComponentClass.prototype = proto;
      function Component(id) {
        BaseComponent.call(this, id);
      }
      if (!proto.___isComponent) {
        inherit(ComponentClass, BaseComponent);
      }
      proto = Component.prototype = ComponentClass.prototype;
      Component.___isComponent = true;
      function State(component) {
        BaseState.call(this, component);
      }
      inherit(State, BaseState);
      proto.___State = State;
      proto.___renderer = renderer;
      return Component;
    };
  }
});

export {
  require_update_manager,
  require_defineComponent
};
//# sourceMappingURL=chunk-BFAZ6O7V.js.map
