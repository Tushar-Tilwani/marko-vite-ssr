import {
  require_defineComponent
} from "./chunk-BFAZ6O7V.js";
import {
  require_index_browser
} from "./chunk-DDL5ICIO.js";
import {
  require_fragment
} from "./chunk-PWCIM3WU.js";
import {
  require_ComponentDef,
  require_constants
} from "./chunk-EX4AML7V.js";
import {
  require_ComponentsContext
} from "./chunk-GIKHVMKU.js";
import {
  require_complain
} from "./chunk-AUY6IS4O.js";
import {
  require_event_delegation
} from "./chunk-CNQJXT2F.js";
import {
  require_dom_data,
  require_index_browser as require_index_browser2
} from "./chunk-XOFOD672.js";
import {
  __commonJS,
  __require
} from "./chunk-VUNV25KB.js";

// node_modules/warp10/src/finalize.js
var require_finalize = __commonJS({
  "node_modules/warp10/src/finalize.js"(exports, module) {
    var constants = require_constants();
    var isArray = Array.isArray;
    function resolve(object, path, len) {
      var current = object;
      for (var i = 0; i < len; i++) {
        current = current[path[i]];
      }
      return current;
    }
    function resolveType(info) {
      if (info.type === "Date") {
        return new Date(info.value);
      } else if (info.type === "URL") {
        return new URL(info.value);
      } else if (info.type === "URLSearchParams") {
        return new URLSearchParams(info.value);
      } else if (info.type === "NOOP") {
        return constants.NOOP;
      } else {
        throw new Error("Bad type");
      }
    }
    module.exports = function finalize(outer) {
      if (!outer) {
        return outer;
      }
      var assignments = outer.$$;
      if (assignments) {
        var object = outer.o;
        var len;
        if (assignments && (len = assignments.length)) {
          for (var i = 0; i < len; i++) {
            var assignment = assignments[i];
            var rhs = assignment.r;
            var rhsValue;
            if (isArray(rhs)) {
              rhsValue = resolve(object, rhs, rhs.length);
            } else {
              rhsValue = resolveType(rhs);
            }
            var lhs = assignment.l;
            var lhsLast = lhs.length - 1;
            if (lhsLast === -1) {
              object = outer.o = rhsValue;
              break;
            } else {
              var lhsParent = resolve(object, lhs, lhsLast);
              lhsParent[lhs[lhsLast]] = rhsValue;
            }
          }
        }
        assignments.length = 0;
        return object == null ? null : object;
      } else {
        return outer;
      }
    };
  }
});

// node_modules/warp10/finalize.js
var require_finalize2 = __commonJS({
  "node_modules/warp10/finalize.js"(exports, module) {
    module.exports = require_finalize();
  }
});

// node_modules/marko/src/node_modules/@internal/require/index-browser.js
var require_index_browser3 = __commonJS({
  "node_modules/marko/src/node_modules/@internal/require/index-browser.js"(exports, module) {
    "use strict";
    load.e = exists;
    module.exports = load;
    function load(id) {
      return interopRequire(__require(id));
    }
    function exists() {
      return false;
    }
    function interopRequire(mod) {
      return mod.default || mod;
    }
  }
});

// node_modules/marko/src/node_modules/@internal/components-registry/index-browser.js
var require_index_browser4 = __commonJS({
  "node_modules/marko/src/node_modules/@internal/components-registry/index-browser.js"(exports) {
    var complain = require_complain();
    var setImmediate = require_index_browser().___setImmediate;
    var warp10Finalize = require_finalize2();
    var defineComponent = require_defineComponent();
    var eventDelegation = require_event_delegation();
    var createFragmentNode = require_fragment().___createFragmentNode;
    var ComponentDef = require_ComponentDef();
    var domData = require_dom_data();
    var componentsUtil = require_index_browser2();
    var req = require_index_browser3();
    var componentLookup = componentsUtil.___componentLookup;
    var addComponentRootToKeyedElements = componentsUtil.___addComponentRootToKeyedElements;
    var keysByDOMNode = domData.___keyByDOMNode;
    var keyedElementsByComponentId = domData.___ssrKeyedElementsByComponentId;
    var componentsByDOMNode = domData.___componentByDOMNode;
    var serverComponentRootNodes = {};
    var serverRenderedMeta = {};
    var win = window;
    win.Marko = {
      Component: function() {
      }
    };
    var DEFAULT_RUNTIME_ID = "M";
    var FLAG_WILL_RERENDER_IN_BROWSER = 1;
    var registered = {};
    var loaded = {};
    var componentTypes = {};
    var deferredDefs;
    var pendingDefs;
    function register(type, def) {
      var pendingForType;
      if (pendingDefs) {
        pendingForType = pendingDefs[type];
      }
      registered[type] = def;
      delete loaded[type];
      delete componentTypes[type];
      if (pendingForType) {
        delete pendingDefs[type];
        setImmediate(function() {
          pendingForType.forEach(function(args) {
            tryHydrateComponent(args[0], args[1], args[2], args[3])();
          });
        });
      }
      return type;
    }
    function addPendingDef(def, type, meta, host, runtimeId) {
      if (!pendingDefs) {
        pendingDefs = {};
      }
      (pendingDefs[type] = pendingDefs[type] || []).push([
        def,
        meta,
        host,
        runtimeId
      ]);
    }
    function load(typeName, isLegacy) {
      var target = loaded[typeName];
      if (!target) {
        target = registered[typeName];
        if (target) {
          target = target();
        } else if (isLegacy) {
          target = exports.___legacy.load(typeName);
        } else {
          target = req(typeName);
          if ("MARKO_DEBUG") {
            complain(
              "Looks like you used `require:` in your browser.json to load a component.  This requires that Marko has knowledge of how lasso generates paths and will be removed in a future version.  `marko-dependencies:/path/to/template.marko` should be used instead."
            );
          }
        }
        if (!target) {
          throw Error("Component not found: " + typeName);
        }
        loaded[typeName] = target;
      }
      return target;
    }
    function getComponentClass(typeName, isLegacy) {
      var ComponentClass = componentTypes[typeName];
      if (ComponentClass) {
        return ComponentClass;
      }
      ComponentClass = load(typeName, isLegacy);
      ComponentClass = ComponentClass.Component || ComponentClass;
      if (!ComponentClass.___isComponent) {
        ComponentClass = defineComponent(ComponentClass, ComponentClass.renderer);
      }
      ComponentClass.prototype.___type = typeName;
      if ("MARKO_DEBUG") {
        var classNameMatch = /\/([^/]+?)(?:\/index|\/template|)(?:\.marko|\.component(?:-browser)?|)$/.exec(
          typeName
        );
        var className = classNameMatch ? classNameMatch[1] : "AnonymousComponent";
        className = className.replace(/-(.)/g, function(g) {
          return g[1].toUpperCase();
        });
        className = className.replace(/\$\d+\.\d+\.\d+$/, "").replace(/^[^a-z$_]/i, "_$&").replace(/[^0-9a-z$_]+/gi, "_");
        className = className[0].toUpperCase() + className.slice(1);
        var OldComponentClass = ComponentClass;
        ComponentClass = {
          [className]: function(id, doc) {
            OldComponentClass.call(this, id, doc);
          }
        }[className];
        ComponentClass.prototype = OldComponentClass.prototype;
      }
      componentTypes[typeName] = ComponentClass;
      return ComponentClass;
    }
    function createComponent(typeName, id, isLegacy) {
      var ComponentClass = getComponentClass(typeName, isLegacy);
      return new ComponentClass(id);
    }
    function indexServerComponentBoundaries(node, runtimeId, stack) {
      var componentId;
      var ownerId;
      var ownerComponent;
      var keyedElements;
      var nextSibling;
      var runtimeLength = runtimeId.length;
      stack = stack || [];
      node = node.firstChild;
      while (node) {
        nextSibling = node.nextSibling;
        if (node.nodeType === 8) {
          var commentValue = node.nodeValue;
          if (commentValue.slice(0, runtimeLength) === runtimeId) {
            var firstChar = commentValue[runtimeLength];
            if (firstChar === "^" || firstChar === "#") {
              stack.push(node);
            } else if (firstChar === "/") {
              var endNode = node;
              var startNode = stack.pop();
              var rootNode;
              if (startNode.parentNode === endNode.parentNode) {
                rootNode = createFragmentNode(startNode.nextSibling, endNode);
              } else {
                rootNode = createFragmentNode(
                  endNode.parentNode.firstChild,
                  endNode
                );
              }
              componentId = startNode.nodeValue.substring(runtimeLength + 1);
              firstChar = startNode.nodeValue[runtimeLength];
              if (firstChar === "^") {
                var parts = componentId.split(/ /g);
                var key = parts[2];
                ownerId = parts[1];
                componentId = parts[0];
                if (ownerComponent = componentLookup[ownerId]) {
                  keyedElements = ownerComponent.___keyedElements;
                } else {
                  keyedElements = keyedElementsByComponentId[ownerId] || (keyedElementsByComponentId[ownerId] = {});
                }
                addComponentRootToKeyedElements(
                  keyedElements,
                  key,
                  rootNode,
                  componentId
                );
              }
              serverComponentRootNodes[componentId] = rootNode;
              startNode.parentNode.removeChild(startNode);
              endNode.parentNode.removeChild(endNode);
            }
          }
        } else if (node.nodeType === 1) {
          var markoKey = node.getAttribute("data-marko-key");
          var markoProps = componentsUtil.___getMarkoPropsFromEl(node);
          if (markoKey) {
            var separatorIndex = markoKey.indexOf(" ");
            ownerId = markoKey.substring(separatorIndex + 1);
            markoKey = markoKey.substring(0, separatorIndex);
            if (ownerComponent = componentLookup[ownerId]) {
              keyedElements = ownerComponent.___keyedElements;
            } else {
              keyedElements = keyedElementsByComponentId[ownerId] || (keyedElementsByComponentId[ownerId] = {});
            }
            keysByDOMNode.set(node, markoKey);
            keyedElements[markoKey] = node;
          }
          if (markoProps) {
            Object.keys(markoProps).forEach(function(key2) {
              if (key2.slice(0, 2) === "on") {
                eventDelegation.___addDelegatedEventHandler(key2.slice(2));
              }
            });
          }
          indexServerComponentBoundaries(node, runtimeId, stack);
        }
        node = nextSibling;
      }
    }
    function invokeComponentEventHandler(component, targetMethodName, args) {
      var method = component[targetMethodName];
      if (!method) {
        throw Error("Method not found: " + targetMethodName);
      }
      method.apply(component, args);
    }
    function addEventListenerHelper(el, eventType, isOnce, listener) {
      var eventListener = listener;
      if (isOnce) {
        eventListener = function(event) {
          listener(event);
          el.removeEventListener(eventType, eventListener);
        };
      }
      el.addEventListener(eventType, eventListener, false);
      return function remove() {
        el.removeEventListener(eventType, eventListener);
      };
    }
    function addDOMEventListeners(component, el, eventType, targetMethodName, isOnce, extraArgs, handles) {
      var removeListener = addEventListenerHelper(
        el,
        eventType,
        isOnce,
        function(event) {
          var args = [event, el];
          if (extraArgs) {
            args = extraArgs.concat(args);
          }
          invokeComponentEventHandler(component, targetMethodName, args);
        }
      );
      handles.push(removeListener);
    }
    function initComponent(componentDef, host) {
      var component = componentDef.___component;
      if (!component || !component.___isComponent) {
        return;
      }
      component.___reset();
      component.___host = host;
      var isExisting = componentDef.___isExisting;
      if (isExisting) {
        component.___removeDOMEventListeners();
      }
      var domEvents = componentDef.___domEvents;
      if (domEvents) {
        var eventListenerHandles = [];
        domEvents.forEach(function(domEventArgs) {
          var eventType = domEventArgs[0];
          var targetMethodName = domEventArgs[1];
          var eventEl = component.___keyedElements[domEventArgs[2]];
          var isOnce = domEventArgs[3];
          var extraArgs = domEventArgs[4];
          addDOMEventListeners(
            component,
            eventEl,
            eventType,
            targetMethodName,
            isOnce,
            extraArgs,
            eventListenerHandles
          );
        });
        if (eventListenerHandles.length) {
          component.___domEventListenerHandles = eventListenerHandles;
        }
      }
      if (component.___mounted) {
        component.___emitUpdate();
      } else {
        component.___mounted = true;
        component.___emitMount();
      }
    }
    function initClientRendered(componentDefs, host) {
      if (!host) host = document;
      eventDelegation.___init(host);
      var len = componentDefs.length;
      var componentDef;
      var i;
      for (i = len; i--; ) {
        componentDef = componentDefs[i];
        trackComponent(componentDef);
      }
      for (i = len; i--; ) {
        componentDef = componentDefs[i];
        initComponent(componentDef, host);
      }
    }
    function initServerRendered(renderedComponents, host) {
      var type = typeof renderedComponents;
      var globalKey = "$";
      var runtimeId;
      if (type !== "object") {
        if (type === "string") {
          runtimeId = renderedComponents;
          globalKey += runtimeId + "_C";
        } else {
          globalKey += (runtimeId = DEFAULT_RUNTIME_ID) + "C";
        }
        renderedComponents = win[globalKey];
        if ("MARKO_DEBUG") {
          if (renderedComponents && renderedComponents.i !== void 0 && renderedComponents.i !== componentsUtil.___runtimeId) {
            console.warn(
              "Multiple instances of Marko have attached to the same runtime id. This could mean that more than one copy of Marko is loaded on the page, or that the script containing Marko has executed more than once."
            );
          }
        }
        var fakeArray = win[globalKey] = {
          r: runtimeId,
          concat: initServerRendered
        };
        if ("MARKO_DEBUG") {
          fakeArray.i = componentsUtil.___runtimeId;
        }
        if (renderedComponents && renderedComponents.forEach) {
          renderedComponents.forEach(function(renderedComponent) {
            fakeArray.concat(renderedComponent);
          });
        }
        return fakeArray;
      }
      var isFromSerializedGlobals = this.concat === initServerRendered;
      renderedComponents = warp10Finalize(renderedComponents);
      if (isFromSerializedGlobals) {
        runtimeId = this.r;
        host = document;
      } else {
        runtimeId = renderedComponents.r || DEFAULT_RUNTIME_ID;
        if (!host) host = document;
        if ("MARKO_DEBUG") {
          complain(
            "Passing serialized data to `require('marko/components).init` is deprecated. Instead set '$global.runtimeId' and provide the 'runtimeId' option to your Marko bundler plugin."
          );
        }
      }
      if ("MARKO_DEBUG") {
        if (host !== document) {
          complain(
            "Passing a document other than the current document to `require('marko/components).init` is deprecated."
          );
        }
      }
      var prefix = renderedComponents.p || "s";
      var meta = serverRenderedMeta[prefix];
      var isLast = renderedComponents.l;
      if (meta) {
        if (isLast) {
          delete serverRenderedMeta[prefix];
        }
      } else {
        meta = {};
        if (!isLast) {
          serverRenderedMeta[prefix] = meta;
        }
      }
      indexServerComponentBoundaries(host, runtimeId);
      eventDelegation.___init(host);
      if (!meta.___globals) {
        meta.___globals = Object.assign({
          runtimeId,
          componentIdPrefix: prefix
        }, renderedComponents.g);
      }
      if (renderedComponents.t) {
        meta.___types = meta.___types ? meta.___types.concat(renderedComponents.t) : renderedComponents.t;
      }
      (renderedComponents.w || []).map(function(componentDef) {
        var typeName = meta.___types[componentDef[1]];
        return registered[typeName] || req.e(typeName) ? tryHydrateComponent(componentDef, meta, host, runtimeId) : addPendingDef(componentDef, typeName, meta, host, runtimeId);
      }).reverse().forEach(tryInvoke);
      return this;
    }
    function tryHydrateComponent(rawDef, meta, host, runtimeId) {
      var componentDef = ComponentDef.___deserialize(
        rawDef,
        meta.___types,
        meta.___globals,
        exports
      );
      var mount = hydrateComponentAndGetMount(componentDef, host);
      if (!mount) {
        if (deferredDefs) {
          deferredDefs.push(componentDef);
        } else {
          deferredDefs = [componentDef];
          document.addEventListener("DOMContentLoaded", function() {
            indexServerComponentBoundaries(host, runtimeId);
            deferredDefs.map(function(componentDef2) {
              return hydrateComponentAndGetMount(componentDef2, host);
            }).reverse().forEach(tryInvoke);
            deferredDefs.length = 0;
          });
        }
      }
      return mount;
    }
    function hydrateComponentAndGetMount(componentDef, host) {
      var componentId = componentDef.id;
      var component = componentDef.___component;
      var rootNode = serverComponentRootNodes[componentId];
      var renderResult;
      if (rootNode) {
        delete serverComponentRootNodes[componentId];
        component.___rootNode = rootNode;
        componentsByDOMNode.set(rootNode, component);
        if (componentDef.___flags & FLAG_WILL_RERENDER_IN_BROWSER) {
          component.___host = host;
          renderResult = component.___rerender(component.___input, true);
          trackComponent(componentDef);
          return function mount() {
            renderResult.afterInsert(host);
          };
        } else {
          trackComponent(componentDef);
        }
        return function mount() {
          initComponent(componentDef, host);
        };
      }
    }
    function trackComponent(componentDef) {
      var component = componentDef.___component;
      if (component) {
        componentLookup[component.id] = component;
      }
    }
    function tryInvoke(fn) {
      if (fn) fn();
    }
    exports.r = register;
    exports.___createComponent = createComponent;
    exports.___getComponentClass = getComponentClass;
    exports.___initServerRendered = win.$initComponents = initServerRendered;
    require_ComponentsContext().___initClientRendered = initClientRendered;
  }
});

export {
  require_index_browser4 as require_index_browser
};
//# sourceMappingURL=chunk-T27UHIJZ.js.map
