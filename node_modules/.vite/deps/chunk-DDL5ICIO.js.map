{
  "version": 3,
  "sources": ["../../marko/src/node_modules/@internal/set-immediate/queueMicrotask.js", "../../marko/src/node_modules/@internal/set-immediate/index-browser.js", "../../marko/src/runtime/createOut.js", "../../events-light/src/index.js", "../../marko/src/runtime/dom-insert.js", "../../marko/src/runtime/RenderResult.js", "../../marko/src/runtime/vdom/morphdom/index.js"],
  "sourcesContent": ["var promise;\nmodule.exports =\n  typeof queueMicrotask === \"function\"\n    ? queueMicrotask\n    : ((promise = Promise.resolve()),\n      function (cb) {\n        promise.then(cb);\n      });\n", "var queue = [];\nvar msg = \"\" + Math.random();\nwindow.addEventListener(\"message\", function (ev) {\n  if (ev.data === msg) {\n    var callbacks = queue;\n    queue = [];\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i]();\n    }\n  }\n});\n\nexports.___setImmediate = function (callback) {\n  if (queue.push(callback) === 1) {\n    window.postMessage(msg, \"*\");\n  }\n};\n\nexports.___queueMicrotask = require(\"./queueMicrotask\");\n", "var actualCreateOut;\n\nfunction setCreateOut(createOutFunc) {\n  actualCreateOut = createOutFunc;\n}\n\nfunction createOut(globalData) {\n  return actualCreateOut(globalData);\n}\n\ncreateOut.___setCreateOut = setCreateOut;\n\nmodule.exports = createOut;\n", "/* jshint newcap:false */\nvar slice = Array.prototype.slice;\n\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\n\nfunction checkListener(listener) {\n    if (!isFunction(listener)) {\n        throw TypeError('Invalid listener');\n    }\n}\n\nfunction invokeListener(ee, listener, args) {\n    switch (args.length) {\n        // fast cases\n        case 1:\n            listener.call(ee);\n            break;\n        case 2:\n            listener.call(ee, args[1]);\n            break;\n        case 3:\n            listener.call(ee, args[1], args[2]);\n            break;\n            // slower\n        default:\n            listener.apply(ee, slice.call(args, 1));\n    }\n}\n\nfunction addListener(eventEmitter, type, listener, prepend) {\n    checkListener(listener);\n\n    var events = eventEmitter.$e || (eventEmitter.$e = {});\n\n    var listeners = events[type];\n    if (listeners) {\n        if (isFunction(listeners)) {\n            events[type] = prepend ? [listener, listeners] : [listeners, listener];\n        } else {\n            if (prepend) {\n                listeners.unshift(listener);\n            } else {\n                listeners.push(listener);\n            }\n        }\n\n    } else {\n        events[type] = listener;\n    }\n    return eventEmitter;\n}\n\nfunction EventEmitter() {\n    this.$e = this.$e || {};\n}\n\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype = {\n    $e: null,\n\n    emit: function(type) {\n        var args = arguments;\n\n        var events = this.$e;\n        if (!events) {\n            return;\n        }\n\n        var listeners = events && events[type];\n        if (!listeners) {\n            // If there is no 'error' event listener then throw.\n            if (type === 'error') {\n                var error = args[1];\n                if (!(error instanceof Error)) {\n                    var context = error;\n                    error = new Error('Error: ' + context);\n                    error.context = context;\n                }\n\n                throw error; // Unhandled 'error' event\n            }\n\n            return false;\n        }\n\n        if (isFunction(listeners)) {\n            invokeListener(this, listeners, args);\n        } else {\n            listeners = slice.call(listeners);\n\n            for (var i=0, len=listeners.length; i<len; i++) {\n                var listener = listeners[i];\n                invokeListener(this, listener, args);\n            }\n        }\n\n        return true;\n    },\n\n    on: function(type, listener) {\n        return addListener(this, type, listener, false);\n    },\n\n    prependListener: function(type, listener) {\n        return addListener(this, type, listener, true);\n    },\n\n    once: function(type, listener) {\n        checkListener(listener);\n\n        function g() {\n            this.removeListener(type, g);\n\n            if (listener) {\n                listener.apply(this, arguments);\n                listener = null;\n            }\n        }\n\n        this.on(type, g);\n\n        return this;\n    },\n\n    // emits a 'removeListener' event iff the listener was removed\n    removeListener: function(type, listener) {\n        checkListener(listener);\n\n        var events = this.$e;\n        var listeners;\n\n        if (events && (listeners = events[type])) {\n            if (isFunction(listeners)) {\n                if (listeners === listener) {\n                    delete events[type];\n                }\n            } else {\n                for (var i=listeners.length-1; i>=0; i--) {\n                    if (listeners[i] === listener) {\n                        listeners.splice(i, 1);\n                    }\n                }\n            }\n        }\n\n        return this;\n    },\n\n    removeAllListeners: function(type) {\n        var events = this.$e;\n        if (events) {\n            delete events[type];\n        }\n    },\n\n    listenerCount: function(type) {\n        var events = this.$e;\n        var listeners = events && events[type];\n        return listeners ? (isFunction(listeners) ? 1 : listeners.length) : 0;\n    }\n};\n\nmodule.exports = EventEmitter;", "var extend = require(\"raptor-util/extend\");\nvar componentsUtil = require(\"@internal/components-util\");\nvar destroyComponentForNode = componentsUtil.___destroyComponentForNode;\nvar destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;\nvar helpers = require(\"./vdom/morphdom/helpers\");\n\nvar insertBefore = helpers.___insertBefore;\nvar insertAfter = helpers.___insertAfter;\nvar removeChild = helpers.___removeChild;\n\nfunction resolveEl(el) {\n  if (typeof el == \"string\") {\n    var elId = el;\n    el = document.getElementById(elId);\n    if (!el) {\n      throw Error(\"Not found: \" + elId);\n    }\n  }\n  return el;\n}\n\nfunction beforeRemove(referenceEl) {\n  destroyNodeRecursive(referenceEl);\n  destroyComponentForNode(referenceEl);\n}\n\nmodule.exports = function (target, getEl, afterInsert) {\n  extend(target, {\n    appendTo: function (referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertBefore(el, null, referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    prependTo: function (referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertBefore(el, referenceEl.firstChild || null, referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    replace: function (referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      beforeRemove(referenceEl);\n      insertBefore(el, referenceEl, referenceEl.parentNode);\n      removeChild(referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    replaceChildrenOf: function (referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n\n      var curChild = referenceEl.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing\n        beforeRemove(curChild);\n        curChild = nextSibling;\n      }\n\n      referenceEl.innerHTML = \"\";\n      insertBefore(el, null, referenceEl);\n      return afterInsert(this, referenceEl);\n    },\n    insertBefore: function (referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertBefore(el, referenceEl, referenceEl.parentNode);\n      return afterInsert(this, referenceEl);\n    },\n    insertAfter: function (referenceEl) {\n      referenceEl = resolveEl(referenceEl);\n      var el = getEl(this, referenceEl);\n      insertAfter(el, referenceEl, referenceEl.parentNode);\n      return afterInsert(this, referenceEl);\n    },\n  });\n};\n", "var domInsert = require(\"./dom-insert\");\n// eslint-disable-next-line no-constant-binary-expression\nvar complain = \"MARKO_DEBUG\" && require(\"complain\");\n\nfunction getRootNode(el) {\n  var cur = el;\n  while (cur.parentNode) cur = cur.parentNode;\n  return cur;\n}\n\nfunction getComponentDefs(result) {\n  var componentDefs = result.___components;\n\n  if (!componentDefs) {\n    throw Error(\"No component\");\n  }\n  return componentDefs;\n}\n\nfunction RenderResult(out) {\n  this.out = this.___out = out;\n  this.___components = undefined;\n}\n\nmodule.exports = RenderResult;\n\nvar proto = (RenderResult.prototype = {\n  getComponent: function () {\n    return this.getComponents()[0];\n  },\n  getComponents: function (selector) {\n    if (this.___components === undefined) {\n      throw Error(\"Not added to DOM\");\n    }\n\n    var componentDefs = getComponentDefs(this);\n\n    var components = [];\n\n    componentDefs.forEach(function (componentDef) {\n      var component = componentDef.___component;\n      if (!selector || selector(component)) {\n        components.push(component);\n      }\n    });\n\n    return components;\n  },\n\n  afterInsert: function (host) {\n    var out = this.___out;\n    var componentsContext = out.___components;\n    if (componentsContext) {\n      this.___components = componentsContext.___initComponents(host);\n    } else {\n      this.___components = null;\n    }\n\n    return this;\n  },\n  getNode: function (host) {\n    return this.___out.___getNode(host);\n  },\n  getOutput: function () {\n    return this.___out.___getOutput();\n  },\n  toString: function () {\n    return this.___out.toString();\n  },\n  document: typeof document === \"object\" && document,\n});\n\nObject.defineProperty(proto, \"html\", {\n  get: function () {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        'The \"html\" property is deprecated. Please use \"toString\" instead.',\n      );\n    }\n    return this.toString();\n  },\n});\n\nObject.defineProperty(proto, \"context\", {\n  get: function () {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        'The \"context\" property is deprecated. Please use \"out\" instead.',\n      );\n    }\n    return this.___out;\n  },\n});\n\n// Add all of the following DOM methods to Component.prototype:\n// - appendTo(referenceEl)\n// - replace(referenceEl)\n// - replaceChildrenOf(referenceEl)\n// - insertBefore(referenceEl)\n// - insertAfter(referenceEl)\n// - prependTo(referenceEl)\ndomInsert(\n  proto,\n  function getEl(renderResult, referenceEl) {\n    return renderResult.getNode(getRootNode(referenceEl));\n  },\n  function afterInsert(renderResult, referenceEl) {\n    return renderResult.afterInsert(getRootNode(referenceEl));\n  },\n);\n", "\"use strict\";\nvar componentsUtil = require(\"@internal/components-util\");\nvar existingComponentLookup = componentsUtil.___componentLookup;\nvar destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;\nvar addComponentRootToKeyedElements =\n  componentsUtil.___addComponentRootToKeyedElements;\nvar normalizeComponentKey = componentsUtil.___normalizeComponentKey;\nvar domData = require(\"../../components/dom-data\");\nvar eventDelegation = require(\"../../components/event-delegation\");\nvar KeySequence = require(\"../../components/KeySequence\");\nvar VElement = require(\"../vdom\").___VElement;\nvar fragment = require(\"./fragment\");\nvar helpers = require(\"./helpers\");\nvar virtualizeElement = VElement.___virtualize;\nvar morphAttrs = VElement.___morphAttrs;\nvar keysByDOMNode = domData.___keyByDOMNode;\nvar componentByDOMNode = domData.___componentByDOMNode;\nvar vElementByDOMNode = domData.___vElementByDOMNode;\nvar detachedByDOMNode = domData.___detachedByDOMNode;\n\nvar insertBefore = helpers.___insertBefore;\nvar insertAfter = helpers.___insertAfter;\nvar nextSibling = helpers.___nextSibling;\nvar firstChild = helpers.___firstChild;\nvar removeChild = helpers.___removeChild;\nvar createFragmentNode = fragment.___createFragmentNode;\nvar beginFragmentNode = fragment.___beginFragmentNode;\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar COMPONENT_NODE = 2;\nvar FRAGMENT_NODE = 12;\nvar DOCTYPE_NODE = 10;\n\n// var FLAG_SIMPLE_ATTRS = 1;\n// var FLAG_CUSTOM_ELEMENT = 2;\n// var FLAG_SPREAD_ATTRS = 4;\n\nfunction isAutoKey(key) {\n  return key[0] !== \"@\";\n}\n\nfunction compareNodeNames(fromEl, toEl) {\n  return fromEl.___nodeName === toEl.___nodeName;\n}\n\nfunction caseInsensitiveCompare(a, b) {\n  return a.toLowerCase() === b.toLowerCase();\n}\n\nfunction onNodeAdded(node, componentsContext) {\n  if (node.nodeType === ELEMENT_NODE) {\n    eventDelegation.___handleNodeAttach(node, componentsContext);\n  }\n}\n\nfunction morphdom(fromNode, toNode, host, componentsContext) {\n  var globalComponentsContext;\n  var isHydrate = false;\n  var keySequences = Object.create(null);\n\n  if (componentsContext) {\n    globalComponentsContext = componentsContext.___globalContext;\n    isHydrate = globalComponentsContext.___isHydrate;\n  }\n\n  function insertVirtualNodeBefore(\n    vNode,\n    key,\n    referenceEl,\n    parentEl,\n    ownerComponent,\n    parentComponent,\n  ) {\n    var realNode = vNode.___actualize(host, parentEl.namespaceURI);\n    insertBefore(realNode, referenceEl, parentEl);\n\n    if (\n      vNode.___nodeType === ELEMENT_NODE ||\n      vNode.___nodeType === FRAGMENT_NODE\n    ) {\n      if (key) {\n        keysByDOMNode.set(realNode, key);\n        (isAutoKey(key) ? parentComponent : ownerComponent).___keyedElements[\n          key\n        ] = realNode;\n      }\n\n      if (vNode.___nodeName !== \"textarea\") {\n        morphChildren(realNode, vNode, parentComponent);\n      }\n\n      onNodeAdded(realNode, componentsContext);\n    }\n  }\n\n  function insertVirtualComponentBefore(\n    vComponent,\n    referenceNode,\n    referenceNodeParentEl,\n    component,\n    key,\n    ownerComponent,\n    parentComponent,\n  ) {\n    var rootNode = (component.___rootNode = insertBefore(\n      createFragmentNode(),\n      referenceNode,\n      referenceNodeParentEl,\n    ));\n    componentByDOMNode.set(rootNode, component);\n\n    if (key && ownerComponent) {\n      key = normalizeComponentKey(key, parentComponent.id);\n      addComponentRootToKeyedElements(\n        ownerComponent.___keyedElements,\n        key,\n        rootNode,\n        component.id,\n      );\n      keysByDOMNode.set(rootNode, key);\n    }\n\n    morphComponent(component, vComponent);\n  }\n\n  function morphComponent(component, vComponent) {\n    morphChildren(component.___rootNode, vComponent, component);\n  }\n\n  var detachedNodes = [];\n\n  function detachNode(node, parentNode, ownerComponent) {\n    if (node.nodeType === ELEMENT_NODE || node.nodeType === FRAGMENT_NODE) {\n      detachedNodes.push(node);\n      detachedByDOMNode.set(node, ownerComponent || true);\n    } else {\n      destroyNodeRecursive(node);\n      removeChild(node);\n    }\n  }\n\n  function destroyComponent(component) {\n    component.destroy();\n  }\n\n  function morphChildren(fromNode, toNode, parentComponent) {\n    var curFromNodeChild = firstChild(fromNode);\n    var curToNodeChild = toNode.___firstChild;\n\n    var curToNodeKey;\n    var curFromNodeKey;\n    var curToNodeType;\n\n    var fromNextSibling;\n    var toNextSibling;\n    var matchingFromEl;\n    var matchingFromComponent;\n    var curVFromNodeChild;\n    var fromComponent;\n\n    outer: while (curToNodeChild) {\n      toNextSibling = curToNodeChild.___nextSibling;\n      curToNodeType = curToNodeChild.___nodeType;\n      curToNodeKey = curToNodeChild.___key;\n\n      // Skip <!doctype>\n      if (curFromNodeChild && curFromNodeChild.nodeType === DOCTYPE_NODE) {\n        curFromNodeChild = nextSibling(curFromNodeChild);\n      }\n\n      var ownerComponent = curToNodeChild.___ownerComponent || parentComponent;\n      var referenceComponent;\n\n      if (curToNodeType === COMPONENT_NODE) {\n        var component = curToNodeChild.___component;\n        if (\n          (matchingFromComponent = existingComponentLookup[component.id]) ===\n          undefined\n        ) {\n          if (isHydrate) {\n            var rootNode = beginFragmentNode(curFromNodeChild, fromNode);\n            component.___rootNode = rootNode;\n            componentByDOMNode.set(rootNode, component);\n\n            if (ownerComponent && curToNodeKey) {\n              curToNodeKey = normalizeComponentKey(\n                curToNodeKey,\n                parentComponent.id,\n              );\n              addComponentRootToKeyedElements(\n                ownerComponent.___keyedElements,\n                curToNodeKey,\n                rootNode,\n                component.id,\n              );\n\n              keysByDOMNode.set(rootNode, curToNodeKey);\n            }\n\n            morphComponent(component, curToNodeChild);\n\n            curFromNodeChild = nextSibling(rootNode);\n          } else {\n            insertVirtualComponentBefore(\n              curToNodeChild,\n              curFromNodeChild,\n              fromNode,\n              component,\n              curToNodeKey,\n              ownerComponent,\n              parentComponent,\n            );\n          }\n        } else {\n          if (matchingFromComponent.___rootNode !== curFromNodeChild) {\n            if (\n              curFromNodeChild &&\n              (fromComponent = componentByDOMNode.get(curFromNodeChild)) &&\n              globalComponentsContext.___renderedComponentsById[\n                fromComponent.id\n              ] === undefined\n            ) {\n              // The component associated with the current real DOM node was not rendered\n              // so we should just remove it out of the real DOM by destroying it\n              curFromNodeChild = nextSibling(fromComponent.___rootNode);\n              destroyComponent(fromComponent);\n              continue;\n            }\n\n            // We need to move the existing component into\n            // the correct location\n            insertBefore(\n              matchingFromComponent.___rootNode,\n              curFromNodeChild,\n              fromNode,\n            );\n          } else {\n            curFromNodeChild =\n              curFromNodeChild && nextSibling(curFromNodeChild);\n          }\n\n          if (!curToNodeChild.___preserve) {\n            morphComponent(component, curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        continue;\n      } else if (curToNodeKey) {\n        curVFromNodeChild = undefined;\n        curFromNodeKey = undefined;\n        var curToNodeKeyOriginal = curToNodeKey;\n\n        if (isAutoKey(curToNodeKey)) {\n          if (ownerComponent !== parentComponent) {\n            curToNodeKey += \":\" + ownerComponent.id;\n          }\n          referenceComponent = parentComponent;\n        } else {\n          referenceComponent = ownerComponent;\n        }\n\n        // We have a keyed element. This is the fast path for matching\n        // up elements\n        curToNodeKey = (\n          keySequences[referenceComponent.id] ||\n          (keySequences[referenceComponent.id] = new KeySequence())\n        ).___nextKey(curToNodeKey);\n\n        if (curFromNodeChild) {\n          curFromNodeKey = keysByDOMNode.get(curFromNodeChild);\n          curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n          fromNextSibling = nextSibling(curFromNodeChild);\n        }\n\n        if (curFromNodeKey === curToNodeKey) {\n          // Elements line up. Now we just have to make sure they are compatible\n          if (!curToNodeChild.___preserve) {\n            // We just skip over the fromNode if it is preserved\n\n            if (\n              curVFromNodeChild &&\n              curToNodeType === curVFromNodeChild.___nodeType &&\n              (curToNodeType !== ELEMENT_NODE ||\n                compareNodeNames(curToNodeChild, curVFromNodeChild))\n            ) {\n              if (curToNodeType === ELEMENT_NODE) {\n                morphEl(\n                  curFromNodeChild,\n                  curVFromNodeChild,\n                  curToNodeChild,\n                  parentComponent,\n                );\n              } else {\n                morphChildren(\n                  curFromNodeChild,\n                  curToNodeChild,\n                  parentComponent,\n                );\n              }\n            } else {\n              // Remove the old node\n              detachNode(curFromNodeChild, fromNode, ownerComponent);\n\n              // Incompatible nodes. Just move the target VNode into the DOM at this position\n              insertVirtualNodeBefore(\n                curToNodeChild,\n                curToNodeKey,\n                curFromNodeChild,\n                fromNode,\n                ownerComponent,\n                parentComponent,\n              );\n            }\n          }\n        } else {\n          matchingFromEl = referenceComponent.___keyedElements[curToNodeKey];\n          if (\n            matchingFromEl === undefined ||\n            matchingFromEl === curFromNodeChild\n          ) {\n            if (isHydrate && curFromNodeChild) {\n              if (\n                curFromNodeChild.nodeType === ELEMENT_NODE &&\n                (curToNodeChild.___preserve ||\n                  caseInsensitiveCompare(\n                    curFromNodeChild.nodeName,\n                    curToNodeChild.___nodeName || \"\",\n                  ))\n              ) {\n                curVFromNodeChild = virtualizeElement(curFromNodeChild);\n                curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;\n                keysByDOMNode.set(curFromNodeChild, curToNodeKey);\n                referenceComponent.___keyedElements[curToNodeKey] =\n                  curFromNodeChild;\n\n                if (curToNodeChild.___preserve) {\n                  vElementByDOMNode.set(curFromNodeChild, curVFromNodeChild);\n                } else {\n                  morphEl(\n                    curFromNodeChild,\n                    curVFromNodeChild,\n                    curToNodeChild,\n                    parentComponent,\n                  );\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n                continue;\n              } else if (\n                curToNodeChild.___nodeType === FRAGMENT_NODE &&\n                curFromNodeChild.nodeType === COMMENT_NODE\n              ) {\n                var content = curFromNodeChild.nodeValue;\n                if (content == \"F#\" + curToNodeKeyOriginal) {\n                  var endNode = curFromNodeChild.nextSibling;\n                  var depth = 0;\n                  var nodeValue;\n\n                  while (true) {\n                    if (endNode.nodeType === COMMENT_NODE) {\n                      nodeValue = endNode.nodeValue;\n                      if (nodeValue === \"F/\") {\n                        if (depth === 0) {\n                          break;\n                        } else {\n                          depth--;\n                        }\n                      } else if (nodeValue.indexOf(\"F#\") === 0) {\n                        depth++;\n                      }\n                    }\n                    endNode = endNode.nextSibling;\n                  }\n\n                  var fragment = createFragmentNode(\n                    curFromNodeChild,\n                    endNode.nextSibling,\n                    fromNode,\n                  );\n                  keysByDOMNode.set(fragment, curToNodeKey);\n                  vElementByDOMNode.set(fragment, curToNodeChild);\n                  referenceComponent.___keyedElements[curToNodeKey] = fragment;\n                  removeChild(curFromNodeChild);\n                  removeChild(endNode);\n\n                  if (!curToNodeChild.___preserve) {\n                    morphChildren(fragment, curToNodeChild, parentComponent);\n                  }\n\n                  curToNodeChild = toNextSibling;\n                  curFromNodeChild = fragment.nextSibling;\n                  continue;\n                }\n              }\n            }\n\n            insertVirtualNodeBefore(\n              curToNodeChild,\n              curToNodeKey,\n              curFromNodeChild,\n              fromNode,\n              ownerComponent,\n              parentComponent,\n            );\n            fromNextSibling = curFromNodeChild;\n          } else {\n            if (detachedByDOMNode.get(matchingFromEl) !== undefined) {\n              detachedByDOMNode.set(matchingFromEl, undefined);\n            }\n\n            if (!curToNodeChild.___preserve) {\n              curVFromNodeChild = vElementByDOMNode.get(matchingFromEl);\n\n              if (\n                curVFromNodeChild &&\n                curToNodeType === curVFromNodeChild.___nodeType &&\n                (curToNodeType !== ELEMENT_NODE ||\n                  compareNodeNames(curVFromNodeChild, curToNodeChild))\n              ) {\n                if (fromNextSibling === matchingFromEl) {\n                  // Single element removal:\n                  // A <-> A\n                  // B <-> C <-- We are here\n                  // C     D\n                  // D\n                  //\n                  // Single element swap:\n                  // A <-> A\n                  // B <-> C <-- We are here\n                  // C     B\n\n                  if (\n                    toNextSibling &&\n                    toNextSibling.___key === curFromNodeKey\n                  ) {\n                    // Single element swap\n\n                    // We want to stay on the current real DOM node\n                    fromNextSibling = curFromNodeChild;\n\n                    // But move the matching element into place\n                    insertBefore(matchingFromEl, curFromNodeChild, fromNode);\n                  } else {\n                    // Single element removal\n\n                    // We need to remove the current real DOM node\n                    // and the matching real DOM node will fall into\n                    // place. We will continue diffing with next sibling\n                    // after the real DOM node that just fell into place\n                    fromNextSibling = nextSibling(fromNextSibling);\n\n                    if (curFromNodeChild) {\n                      detachNode(curFromNodeChild, fromNode, ownerComponent);\n                    }\n                  }\n                } else {\n                  // A <-> A\n                  // B <-> D <-- We are here\n                  // C\n                  // D\n\n                  // We need to move the matching node into place\n                  insertAfter(matchingFromEl, curFromNodeChild, fromNode);\n\n                  if (curFromNodeChild) {\n                    detachNode(curFromNodeChild, fromNode, ownerComponent);\n                  }\n                }\n\n                if (curToNodeType === ELEMENT_NODE) {\n                  morphEl(\n                    matchingFromEl,\n                    curVFromNodeChild,\n                    curToNodeChild,\n                    parentComponent,\n                  );\n                } else {\n                  morphChildren(\n                    matchingFromEl,\n                    curToNodeChild,\n                    parentComponent,\n                  );\n                }\n              } else {\n                insertVirtualNodeBefore(\n                  curToNodeChild,\n                  curToNodeKey,\n                  curFromNodeChild,\n                  fromNode,\n                  ownerComponent,\n                  parentComponent,\n                );\n                detachNode(matchingFromEl, fromNode, ownerComponent);\n              }\n            } else {\n              // preserve the node\n              // but still we need to diff the current from node\n              insertBefore(matchingFromEl, curFromNodeChild, fromNode);\n              fromNextSibling = curFromNodeChild;\n            }\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n        continue;\n      }\n\n      // The know the target node is not a VComponent node and we know\n      // it is also not a preserve node. Let's now match up the HTML\n      // element, text node, comment, etc.\n      while (curFromNodeChild) {\n        fromNextSibling = nextSibling(curFromNodeChild);\n\n        if ((fromComponent = componentByDOMNode.get(curFromNodeChild))) {\n          // The current \"to\" element is not associated with a component,\n          // but the current \"from\" element is associated with a component\n\n          // Even if we destroy the current component in the original\n          // DOM or not, we still need to skip over it since it is\n          // not compatible with the current \"to\" node\n          curFromNodeChild = fromNextSibling;\n\n          if (\n            !globalComponentsContext.___renderedComponentsById[fromComponent.id]\n          ) {\n            destroyComponent(fromComponent);\n          }\n\n          continue; // Move to the next \"from\" node\n        }\n\n        var curFromNodeType = curFromNodeChild.nodeType;\n\n        var isCompatible = undefined;\n\n        if (curFromNodeType === curToNodeType) {\n          if (curFromNodeType === ELEMENT_NODE) {\n            // Both nodes being compared are Element nodes\n            curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n            if (curVFromNodeChild === undefined) {\n              if (isHydrate) {\n                curVFromNodeChild = virtualizeElement(curFromNodeChild);\n\n                if (\n                  caseInsensitiveCompare(\n                    curVFromNodeChild.___nodeName,\n                    curToNodeChild.___nodeName,\n                  )\n                ) {\n                  curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;\n                }\n              } else {\n                // Skip over nodes that don't look like ours...\n                curFromNodeChild = fromNextSibling;\n                continue;\n              }\n            } else if ((curFromNodeKey = curVFromNodeChild.___key)) {\n              // We have a keyed element here but our target VDOM node\n              // is not keyed so this not doesn't belong\n              isCompatible = false;\n            }\n\n            isCompatible =\n              isCompatible !== false &&\n              compareNodeNames(curVFromNodeChild, curToNodeChild) === true;\n\n            if (isCompatible === true) {\n              // We found compatible DOM elements so transform\n              // the current \"from\" node to match the current\n              // target DOM node.\n              morphEl(\n                curFromNodeChild,\n                curVFromNodeChild,\n                curToNodeChild,\n                parentComponent,\n              );\n            }\n          } else if (\n            curFromNodeType === TEXT_NODE ||\n            curFromNodeType === COMMENT_NODE\n          ) {\n            // Both nodes being compared are Text or Comment nodes\n            isCompatible = true;\n            var curToNodeValue = curToNodeChild.___nodeValue;\n            var curFromNodeValue = curFromNodeChild.nodeValue;\n            if (curFromNodeValue !== curToNodeValue) {\n              if (\n                isHydrate &&\n                toNextSibling &&\n                curFromNodeType === TEXT_NODE &&\n                toNextSibling.___nodeType === TEXT_NODE &&\n                curFromNodeValue.startsWith(curToNodeValue) &&\n                curFromNodeValue\n                  .slice(curToNodeValue.length)\n                  .startsWith(toNextSibling.___nodeValue)\n              ) {\n                // In hydrate mode we can use splitText to more efficiently handle\n                // adjacent text vdom nodes that were merged.\n                fromNextSibling = curFromNodeChild.splitText(\n                  curToNodeValue.length,\n                );\n              } else {\n                // Simply update nodeValue on the original node to\n                // change the text value\n                curFromNodeChild.nodeValue = curToNodeValue;\n              }\n            }\n          }\n        }\n\n        if (isCompatible === true) {\n          // Advance both the \"to\" child and the \"from\" child since we found a match\n          curToNodeChild = toNextSibling;\n          curFromNodeChild = fromNextSibling;\n          continue outer;\n        }\n\n        detachNode(curFromNodeChild, fromNode, ownerComponent);\n        curFromNodeChild = fromNextSibling;\n      } // END: while (curFromNodeChild)\n\n      // If we got this far then we did not find a candidate match for\n      // our \"to node\" and we exhausted all of the children \"from\"\n      // nodes. Therefore, we will just append the current \"to\" node\n      // to the end\n      insertVirtualNodeBefore(\n        curToNodeChild,\n        curToNodeKey,\n        curFromNodeChild,\n        fromNode,\n        ownerComponent,\n        parentComponent,\n      );\n\n      curToNodeChild = toNextSibling;\n      curFromNodeChild = fromNextSibling;\n    }\n\n    // We have processed all of the \"to nodes\".\n    if (fromNode.___finishFragment) {\n      // If we are in an unfinished fragment, we have reached the end of the nodes\n      // we were matching up and need to end the fragment\n      fromNode.___finishFragment(curFromNodeChild);\n    } else {\n      // If curFromNodeChild is non-null then we still have some from nodes\n      // left over that need to be removed\n      var fragmentBoundary =\n        fromNode.nodeType === FRAGMENT_NODE ? fromNode.endNode : null;\n\n      while (curFromNodeChild && curFromNodeChild !== fragmentBoundary) {\n        fromNextSibling = nextSibling(curFromNodeChild);\n\n        if ((fromComponent = componentByDOMNode.get(curFromNodeChild))) {\n          curFromNodeChild = fromNextSibling;\n          if (\n            !globalComponentsContext.___renderedComponentsById[fromComponent.id]\n          ) {\n            destroyComponent(fromComponent);\n          }\n          continue;\n        }\n\n        curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n        curFromNodeKey = keysByDOMNode.get(fromNode);\n\n        // For transcluded content, we need to check if the element belongs to a different component\n        // context than the current component and ensure it gets removed from its key index.\n        if (!curFromNodeKey || isAutoKey(curFromNodeKey)) {\n          referenceComponent = parentComponent;\n        } else {\n          referenceComponent =\n            curVFromNodeChild && curVFromNodeChild.___ownerComponent;\n        }\n\n        detachNode(curFromNodeChild, fromNode, referenceComponent);\n\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n  }\n\n  function morphEl(fromEl, vFromEl, toEl, parentComponent) {\n    var nodeName = toEl.___nodeName;\n    var constId = toEl.___constId;\n    vElementByDOMNode.set(fromEl, toEl);\n\n    if (constId !== undefined && vFromEl.___constId === constId) {\n      return;\n    }\n\n    morphAttrs(fromEl, vFromEl, toEl);\n\n    if (toEl.___preserveBody) {\n      return;\n    }\n\n    if (nodeName === \"textarea\") {\n      if (toEl.___valueInternal !== vFromEl.___valueInternal) {\n        fromEl.value = toEl.___valueInternal;\n      }\n    } else {\n      morphChildren(fromEl, toEl, parentComponent);\n    }\n  } // END: morphEl(...)\n\n  morphChildren(fromNode, toNode, toNode.___component);\n\n  detachedNodes.forEach(function (node) {\n    var detachedFromComponent = detachedByDOMNode.get(node);\n\n    if (detachedFromComponent !== undefined) {\n      detachedByDOMNode.set(node, undefined);\n\n      var componentToDestroy = componentByDOMNode.get(node);\n      if (componentToDestroy) {\n        componentToDestroy.destroy();\n      } else if (node.parentNode) {\n        destroyNodeRecursive(\n          node,\n          detachedFromComponent !== true && detachedFromComponent,\n        );\n\n        if (eventDelegation.___handleNodeDetach(node) != false) {\n          removeChild(node);\n        }\n      }\n    }\n  });\n}\n\nmodule.exports = morphdom;\n"],
  "mappings": "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",
  "names": ["require_index_browser", "fromNode", "toNode", "fragment"]
}
